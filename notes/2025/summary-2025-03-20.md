# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-03-20T16:59:23Z
- Meeting end: 2025-03-20T18:04:46Z
- Summary start: 2025-03-20T17:00:33Z
- Summary end: 2025-03-20T18:04:36Z

The team discussed the complexity of satisfiability and the need to simplify it in the spec, considering a two-step process for satisfiability and the use of a graph to navigate through all possible variants. They also explored the algorithm for query planning in a federated system, the optimization of paths in a system, and the tracking and interpretation of options in their system. The team also discussed the use of expression language and path syntax to simplify the information they track and agreed to keep track of their discussion points in a file and potentially start outlining the algorithm.

## Next Steps

- Pascal to start writing a rough outline of the satisfiability algorithm based on the discussion.
- Michael to edit and publish the AI-generated meeting summary in the repository after receiving it from Benjie.
- All participants to review the AI-generated meeting summary once published for accuracy and completeness.
- All participants to prepare for further discussion on the satisfiability algorithm in the next meeting.

## Summary

### Satisfiability Meeting Discussion

Pascal, Martijn, Sachin, Kamil, and Michael discussed the meeting's attendees and their permissions. They clarified the auto-merging rules for the attendee list and removed Derek from the list. Pascal then initiated a round of introductions, with Martijn, Sachin, Kamil, and Michael sharing their affiliations with Apollo and The Guild. Pascal also mentioned that Michael would add himself to the agenda. The main topic of the meeting was satisfiability, which was expected to take up the entire meeting time.

### Satisfiability Complexity and Loop Detection

The team discussed the complexity of satisfiability and the need to simplify it in the spec. They considered a two-step process for satisfiability, where the first step involves generating all possible paths through the GraphQL schema to a leaf field, and the second step involves checking if all these paths are executable for the schema to be satisfiable. However, Sachin pointed out that this approach doesn't work as written, as there are infinite paths and loop detection is needed. The team agreed to revisit the topic and work on examples to better understand the loop detection process. Kamil suggested using a graph to navigate through all possible variants and check if the underlying graph has an option to get there. The team also discussed the need to cache knowledge to optimize the process.

### Stopping Node Visit Algorithm Conditions

Martijn and Sachin discussed the conditions for stopping a node visit in their algorithm. Sachin clarified that stopping is possible when the set of subgraphs is a superset of a previous visit's set of subgraphs, or when the set of subgraphs is equal to a previous visit's set of subgraphs. Pascal added that stopping is also possible when the list of subgraphs is the same or bigger. They also discussed the issue of reaching a point with no options to get somewhere, which would result in an unsatisfiable query. Martijn suggested referring to the list of subgraphs as a list of options for clarity.

### Federated Query Planning Algorithm Discussion

The discussion focuses on the algorithm for query planning in a federated system. Pascal, Martijn, and Sachin explore how to handle paths across multiple source schemas and subgraphs. They discuss keeping track of the current state, which includes the type and possible subgraphs, as the algorithm traverses the public API. The team considers how to handle fields that may be resolvable from different sources and the importance of cross-subgraph edges in expanding the possibilities for query resolution. They emphasize the need to consider all options at each step, including staying within a subgraph or moving to a different one, to ensure comprehensive query planning.

### Optimizing Paths in System Design

In the meeting, Kamil, Martijn, Pascal, and Sachin discussed the optimization of paths in a system. Kamil suggested that if there are multiple paths to the same destination, the system could eliminate the less optimal ones to reduce the number of options. Martijn agreed but pointed out that the algorithm should not be responsible for pruning the options. Pascal emphasized the importance of flexibility in the system, stating that it should not be limited by the schema. Sachin agreed, noting that in query planning, the system should prioritize finding the optimal path. Michael suggested that the algorithms for composition and query planning might be simpler if they were specified separately. The team also discussed the importance of execution behavior and the potential for different implementations to choose different optimization strategies.

### Federated Schema Query Planning Algorithm

Pascal, Martijn, and Sachin discuss an algorithm for query planning in a federated schema. They agree to use a function called "plan options" that takes a path and returns possible source schemas or options at that point. The algorithm recursively traverses the schema, keeping track of the path and available options. They decide to stop the recursion when reaching a leaf field or when encountering a loop with the same options as a previous visit. The team acknowledges that the implementation details may vary depending on the federation features supported, such as context and "provides" directives. They conclude that the concept of subsetting options remains consistent across different federation features, even if the specific data structure for options may change.

### Federation Provides Optimization and Satisfiability

Sachin clarified that in Federation, provides are treated as an optimization and are not considered when it comes to satisfiability. He explained that even without provides, the schema should still be satisfiable. Pascal raised a concern about the possibility of a query being satisfiable with provides but not without them, but Sachin reassured that provides only offer more options and are not necessary at runtime. Michael agreed, stating that provides are just a shortcut. The team also discussed the potential for anti-patterns in designing the schema if the only way to make it satisfiable is through provides. They concluded that plan options allow them to abstract away these specifics.

### Type Explosion and Interface Usage

The team discussed the tracking and interpretation of options in their system. Sachin explained that the current system only considers type conditions to object types, and that the behavior on type explosion allows for simplification of options interpretation. Martijn and Pascal questioned how interfaces fit into this, and Sachin clarified that interfaces could be treated as a shorthand notation for creating virtual types. The team also discussed the use of interface objects to avoid subgraphs from having to know about all possible types, and how this could be used to return any product without knowing about all the possible types that implement it. The team agreed that interfaces matter for satisfiability, and that the paths should have type information.

### Simplifying Information Tracking With Expression Language

Pascal, Martijn, and Sachin discussed the use of expression language and path syntax to simplify the information they track. They agreed that the context data they store includes type and options, and only if there's an exact match or a subset of any of the sets, they can stop. Michael suggested that the AI summary would need human editing and would be useful for compressing and providing more context. They decided to keep track of their discussion points in a file and potentially start outlining the algorithm. They agreed to meet again next week.
