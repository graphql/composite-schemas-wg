# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-04-03T16:00:15Z
- Meeting end: 2025-04-03T16:55:53Z
- Summary start: 2025-04-03T16:01:02Z
- Summary end: 2025-04-03T16:55:46Z

The team discussed various aspects of their project, including AI capabilities, algorithm development, and schema satisfiability. They focused on implementing a plan options function and validating the algorithm for checking schema satisfiability in federated GraphQL. The conversation ended with discussions on error handling, dev tooling improvements, and plans for future review and specification updates.

## Next Steps

- Pascal to write a first draft of a possible satisfiability algorithm validation in a simple form based on the discussed approach.
- Michael to create a pull request for the AI meeting summaries for the team to review.
- All team members to review the AI meeting summary pull request when available.
- Pascal to create GitHub issues for the four new validation rules related to the "is" directive.
- All team members to asynchronously review the new validation rules for the "is" directive once Pascal posts the GitHub links in the Slack channel.

## Summary

### Team Discusses Haircuts and AI Capabilities

The team discussed their haircuts and the AI's image optimization capabilities. Michael mentioned that he would add notes from the AI to the repository and merge it for better process. Pascal suggested using AI to clean up the notes. The team also discussed the absence of Derek and Session, with Shane attempting to contact them. The conversation ended with a quick round of introductions, with Michael, Shane, Martijn, Pascal, and Kamil introducing themselves.

### Algorithm for Plan Options Discussion

Michael and Pascal discussed the algorithm for plan options, which involves passing in a path and getting out the possible options where they can go and visit. They decided that requires will be handled in plan options and that provides is just metadata and shouldn't change the execution. They also discussed the importance of considering the whole query path when determining if a requirement can be satisfied. They agreed that the plan options function will only yield fields where they can fulfill the requirement at that point. They also discussed the need to ensure that the requirement can be satisfied, and that this is not just a runtime optimization but a requirement for satisfiability.

### Schema Satisfiability Check Implementation

In the meeting, Michael, Martijn, Pascal, and Kamil discussed the implementation of a satisfiability check on the schema with the assumption that they have plan options. They considered the use of the syntax for selection paths and the need for a public schema and subgraph schemas. They also discussed the potential for loops and the need for recursive types. The team agreed to manually validate the algorithm with the assumption of plan options and to define a schema with lookups to understand how the algorithm would work in practice. They also considered the need for a set of test cases to approach the problem.

### Federated GraphQL Schema Satisfiability Algorithm

The group discusses the algorithm for checking schema satisfiability in federated GraphQL. They agree to use a bookshop-themed schema for examples. The algorithm involves traversing the public API schema graph, checking if each field can be resolved in at least one subgraph. They debate the specifics of graph representation and traversal methods, with some differences in implementation between team members. The group concludes that the specification should describe this process at a higher level of abstraction, focusing on the ability to check field availability in subgraphs rather than specifying exact implementation details.

### Algorithm for Satisfiability in Query Planning

Pascal discussed the algorithm for satisfiability in the context of query planning and validation. He proposed a simple algorithm that involves traversing the graph, checking for stopping conditions, and handling different types of errors. Martijn suggested using a set of options instead of a list to avoid specifying a concrete data structure. The team agreed to continue with the new specification and review it next week. Michael suggested posting the validation rules on Github for review. The team also discussed the need for better dev tooling to handle errors efficiently.
