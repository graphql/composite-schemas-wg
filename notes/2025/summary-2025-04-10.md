# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-04-10T15:58:54Z
- Meeting end: 2025-04-10T16:59:12Z
- Summary start: 2025-04-10T16:01:25Z
- Summary end: 2025-04-10T16:59:07Z

The team discussed a new pull request for satisfiability created by Pascal, focusing on the validation of the satisfiability section in the composite schemas specification and the algorithm for checking visited states in a graph traversal. They also explored optimizing the code for handling scalar and enum types in field processing, and discussed various errors and their solutions in relation to schema composition and satisfiability. Lastly, they delved into technical issues related to schema design and composition in a federated system, the complexities of plan options and query planning, and the challenges of fetching data from lists.

## Next Steps

- All attendees to review and annotate the latest version of Pascal's pull request for satisfiability.
- All attendees to consider and prepare thoughts on how to approach execution specification in the spec for the next meeting.
- Pascal to update the examples in the pull request to ensure they are fully valid source schemas.
- All attendees to think about the level of detail needed for specifying plan options and execution in the spec.
- Pascal to consider how to incorporate the execution details into the plan options specification.

## Summary

### Reviewing New Pull Request

The group discusses a new pull request for satisfiability created by Pascal. Michael, the host, introduces the meeting and reminds everyone of the GraphQL spec membership agreement and code of conduct. The attendees introduce themselves, with several members from Apollo present. Pascal suggests going through the pull request together before having a discussion about it.

### Composite Schemas Satisfiability Validation

Pascal discussed the validation of the satisfiability section in the composite schemas specification. He explained that the section merges many source schemas into one and ensures that all fields or possible paths are resolvable. He also mentioned that if at any point along the path the option set is empty, it means that no source schema is able to resolve that field, and the path is considered unsatisfiable. Pascal also introduced the concept of path and its sequence of field selections through the composite schema. He further explained the algorithm for satisfiability check, which involves constructing the initial path, exploring the paths, and checking for loop detection. The algorithm also involves checking if the resulting set of source schemas is ever empty, and if it is, the schemas are deemed unsatisfiable.

### Refining Algorithm for Visited States

The team discusses the algorithm for checking visited states in a graph traversal. Sachin points out that the condition for skipping already visited states should be refined. They clarify that if the current options are a superset of previously visited options for the same type, the algorithm can safely skip further exploration. Pascal acknowledges this correction and agrees to fix the algorithm accordingly. The team also briefly mentions the need for more comments on the pull request and potential optimizations.

### Optimizing Scalar and Enum Type Handling

The team discusses optimizing the code for handling scalar and enum types in field processing. They decide to move the check for scalar and enum types earlier in the code, specifically after line 6,207. Martijn points out that using 'possible type' for scalars is unusual, as it's typically used for object types. The team agrees to modify the code to handle scalars and enums separately, with Michael confirming that possible types are associated with abstract types and composite types, but not with scalars.

### Satisfiability Errors and Schema Decisions

Pascal and Martijn discussed the implementation of an algorithm, with Martijn suggesting the removal of a certain type. Pascal then shared a case study on satisfiability errors and their potential impact on schema decisions. Michael mentioned working with Glen on test cases for the implementation. Pascal encouraged anyone with additional examples of satisfiability errors to add them as comments for further specification.

### Schema Composition and Satisfiability Errors

In the meeting, the team discussed various errors and their solutions in relation to schema composition and satisfiability. They focused on the importance of key directives and the need for a common naming convention to avoid errors. The team also discussed the concept of value types and how they differ between different versions of their system. They agreed that some errors, such as mismatched keys, are satisfiability errors rather than composition errors. The team also discussed the need for more detailed explanations of these errors and how they can be resolved.

### Schema Design and Composition Issues

The group discusses various technical issues related to schema design and composition in a federated system. They explore problems that can arise when types are marked as shareable or when fields are inconsistently defined across schemas. Pascal presents examples of potential composition errors, including cases where a type is an entity in one schema but a value type in another. The team also debates the merits of adding default values to fields and the potential for abuse. They conclude by examining a scenario where a category type lacks a lookup, discussing how this affects resolution and composition across schemas.

### Query Planning and Execution Complexity

The team discussed the complexities of plan options and query planning in their system. They considered different approaches to execution, including the possibility of describing it based on a query graph or on a query basis. The team also discussed the need to specify the equivalent of a query graph and the details of subgraph jumps. They agreed that the system should be able to find the appropriate collection of subgraph queries that could resolve a path. The team also discussed the need to optimize the system, such as deciding which option to choose for better performance.

### Nested List Data Fetching Challenges

In the meeting, Pascal and Michael discussed the challenges of fetching data from lists, particularly when dealing with nested lists. They considered the possibility of merging queries to reduce network overhead, but acknowledged the complexity of the algorithm. The team agreed to continue working on the issue and to think about how to approach the execution of queries. They also discussed the need for clear plan options and the potential for reusing execution bits in the plan options. The conversation ended with a plan to reconvene next week to further discuss the topic.
