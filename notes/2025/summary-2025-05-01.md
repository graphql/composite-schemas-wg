# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-05-01T16:00:15Z
- Meeting end: 2025-05-01T16:58:47Z
- Summary start: 2025-05-01T16:00:42Z
- Summary end: 2025-05-01T16:58:44Z

The team discussed the implementation of a query plan execution algorithm, focusing on defining the plan options algorithm and tracking additional states for better understanding of the algorithm. They also considered alternative names for the concept of "plan options" and the idea of tracking the state of the plan. The team also discussed the complexities of their algorithm, particularly focusing on the nested loops and the need for a while loop on a queue, as well as the issue of subgraph jumps and the additional requirements that fields might have.

## Next Steps

- Pascal to write down a basic algorithm for plan options and post it in the Slack channel for review and comments.
- Team to review and discuss Pascal's proposed algorithm for plan options in the next meeting.
- Team to consider additional complexities like abstract types and possible type explosion after finalizing the basic algorithm.

## Summary

### City Names and GraphQL Foundation

In the meeting, the attendees discussed various topics including the ambiguity of city names in different countries, the Wooden Shoe Festival in Holland, Michigan, and the Labor Day holiday. They also discussed the GraphQL Spec Membership Agreement and the GraphQL Foundation Code of conduct. The conversation ended with a round of introductions from the participants.

### Composite Schema Panel at GraphQLConf

The team discussed the possibility of organizing a panel or working session on the composite schema work group at the GraphQLConf. Jeff confirmed the interest of the conference committee in this idea and suggested it could be incorporated into the day's agenda. The team agreed to submit a proposal for the panel, which would be a priority for the conference committee. The conversation ended with a decision to focus on execution and plan options for the next 15 minutes.

### Query Plan Execution Algorithm Discussion

In the meeting, Pascal, Michael, Shane, Martijn, and Sachin discussed the implementation of a query plan execution algorithm. They considered three approaches: specifying a complex algorithm, using a pseudo algorithm, and defining the plan options. The group agreed to define the plan options algorithm, which would involve resolving requirements, lookups, and field searches. They also discussed the need to track additional states for better understanding of the algorithm. The output of the plan options algorithm would be a set of possible schemas to locate the query from. The team also discussed the possibility of tracking the path through the options and the steps taken to satisfy each option.

### Flexible Query Plan Visualization

Michael proposed a new approach to testing query plans, focusing on observable results rather than specifying a standard format for query plans. He suggested that the implementation should be flexible and not restricted to a specific query planner. Pascal agreed, noting that different implementations might have different optimizations and that a generic concept for visualizing query plans could be beneficial. Martijn suggested that a separate tooling spec could be created for this purpose. Derek proposed verifying query plans algorithmically to ensure semantic equivalence. The team agreed that the specification should not enforce identical query plans for different implementations, allowing for innovation and different approaches.

### Plan Options Naming Discussion

Pascal, Michael, and Martijn discussed the concept of "plan options" in their system. They agreed that the term "plan" might be misleading, as it doesn't involve actual execution but rather provides a description of how to execute. They considered alternative names such as "retrieve options" or "resolve path". The team also discussed the idea of tracking the state of the plan, like the steps to be taken to execute it. They concluded that the name could be decided after the algorithm is developed.

### Profile Field Query Algorithm Discussion

Pascal discussed the algorithm for handling profile fields in a query. He explained that the process starts with the root field, which could be a public root field of a subgraph. The algorithm checks if the query type is available on the options, initially considering all source schemas as possible options. As the algorithm progresses, it narrows down the options based on the specific source schemas that have the profile field. Martijn and Michael clarified that the algorithm starts with a specific path and only considers subgraphs that have the root field available. They also noted that the options grow as the algorithm progresses through the query execution.

### Algorithm Implementation and Requirement Validation

The team discussed the implementation details of their algorithm, focusing on the representation of options and requirements. They agreed that the output of the plan options should not include requirements, as this would complicate the specification and potentially lead to an explosion of complexity. Instead, they proposed that the algorithm should check for requirements at each field and validate them, without duplicating options. The team also discussed the need to track context data outside of the options, particularly for lookups. They concluded that the algorithm should be designed to handle multiple paths and requirements, but the specification should not require planning every possibility.

### Nested Fields and Entity Context

Martijn and Pascal discussed the structure of entities and nested fields in their system. Pascal raised a concern about the need to know the context of the parent entity when dealing with nested fields. Martijn clarified that once in a nested field, one would either stay there or move to another entity, and the context of the parent entity would not be needed. Michael agreed with Martijn's explanation. Pascal acknowledged Martijn's point, stating that the requirement would only come into effect when dealing with multiple fields.

### Algorithm Complexity and Subgraph Jumps

In the meeting, Martijn, Pascal, and Michael discussed the complexities of their algorithm, particularly focusing on the nested loops and the need for a while loop on a queue. They also touched on the issue of subgraph jumps and the additional requirements that fields might have. Pascal suggested writing down the basic algorithm and posting it in the Slack channel for further discussion. They also mentioned the need to consider complications like abstract types and possible type explosion in the future.
