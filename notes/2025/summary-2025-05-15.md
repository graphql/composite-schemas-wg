# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-05-15T15:58:10Z
- Meeting end: 2025-05-15T16:52:00Z
- Summary start: 2025-05-15T16:01:58Z
- Summary end: 2025-05-15T16:51:48Z

The meeting focused on discussing and refining a planning algorithm for schema traversal and requirement resolution. Participants explored various aspects of the algorithm, including satisfiability, reachability between schemas, and handling nested fields and requirements. The team identified challenges in implementing the algorithm and agreed to review their work, create a reference implementation, and continue discussions in future meetings.

## Next Steps

- Pascal to push the updated algorithm to a pull request and share the link in Slack.
- All attendees to review and comment on the pull request for the updated plan options algorithm.
- All attendees to think about and potentially propose better ideas for the algorithm in between meetings.
- Victor to add himself to the meeting agenda.

## Summary

### Planning Algorithm and Temporal Logic

Michael led a meeting with various participants, including Martijn, Pascal, Stephen, and Kamil. The meeting began with a round of introductions, followed by a discussion on the planning algorithm from the previous week. Martijn mentioned he might need to leave for a bit to get food, but would keep his audio on. Pascal expressed interest in discussing temporal logic, a topic they had previously discussed. Michael then passed the discussion over to Pascal.

### Satisfiability Pull Request Updates

Pascal discussed updates to the satisfiability pull request, including fixing Martin's issue with the source scheme. Pascal also presented a rough algorithm for reducing the initial set to only the schemas that define the schema. The main topic of discussion was the resolve requirement function, which involves checking requirements on fields and merging requirements. Pascal raised questions about the complexity of the algorithm and the definition of a switchable. Michael and Martijn provided input on the use of the 'is reachable' function and the need for a source point.

### Algorithm Refinement for Schema Transition

Pascal and Michael discuss the algorithm for resolving requirements and transitioning between schemas. They identify an issue with the current implementation, noting that both the current schema and candidate schema need to be considered. They agree that it's acceptable to pass requirements from the current schema to a new candidate schema. The team refines the algorithm for checking reachability between schemas and resolving requirements, considering nested loops and potential recursive calls. They also discuss how to handle lookups and their associated keys, treating them as requirements. The conversation concludes with Pascal outlining the steps for the revised algorithm, including initializing schemas, checking for field definitions, resolving requirements, and determining reachability between schemas.

### Nested Fields and Requirement Handling

Pascal and Martijn discussed the concept of nested fields and requirements in their system. Pascal raised the question of whether a requirement could be a nested field, and Martijn agreed that it should be able to handle this. Pascal also suggested that the key field should not be restricted to one schema, and Michael agreed that a requirement technique could come from multiple schemas. Pascal proposed that the system should be more specific about what requirements are, and suggested that the output should be a flat list of required fields or paths. They also discussed the possibility of having a field path that is not defined by a type, and the need to go through each element of the path again.

### Recursive Plan Options Algorithm Challenges

The group discusses the challenges of implementing a recursive plan options algorithm for schema traversal. Pascal proposes a complex approach involving internal plan options and schema comparisons, but Martijn points out potential issues with loops and validity. They debate the need for separating current and other schemas, and consider the implications of starting from the query root. The conversation highlights the difficulty of validating such an algorithm without a reference implementation. Michael humorously remarks on the complexity, and the group acknowledges the need for a practical, implementable solution that avoids immediate disaster.

### Reviewing Work and Planning Next Steps

In the meeting, Pascal and Michael discussed the need for a fresh perspective and careful consideration of potential issues in their work. They agreed to review and iterate on their work over the next few weeks. Pascal also mentioned the importance of avoiding loops and recursive requirements. Michael suggested looking at the problem asynchronously and proposed a function for validating their work. The team also discussed the need for a reference implementation of their specification. They decided to put their work in a pull request for further review. The conversation ended with Pascal mentioning a new attendee, Victor, and the plan to continue the discussion next week.
