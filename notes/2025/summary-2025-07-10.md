# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-07-10T15:58:44Z
- Meeting end: 2025-07-10T16:57:18Z
- Summary start: 2025-07-10T16:01:13Z
- Summary end: 2025-07-10T16:57:14Z

The meeting focused on discussing various technical issues and terminology related to GraphQL Federation and subgraphs. The team explored topics such as the use of "requires" versus "external" directives, handling interfaces across subgraphs, and validation rules for shareable fields. They also addressed concerns about error handling, query planning, and the use of nodes versus lookups in subgraphs, ultimately making decisions to improve system consistency and efficiency.

## Next Steps

- Michael to update the external directive and describe the use case for interfaces discussed in the meeting.
- Pascal to add an example to the issue regarding valid use cases for shareable fields with non-intersecting interface implementations.
- Team to implement a satisfiability check for shareable fields returning abstract types with non-intersecting implementations across subgraphs.
- Michael to write down the decisions made on each of the discussed issues.
- Team to review and discuss the remaining 4-5 issues not covered in this meeting at the next meeting.

## Summary

### GraphQL Spec Membership Introduction

The meeting began with introductions from Michael, Martijn, Benjamin, Sachin, Kamil, Duckki, and Pascal, who represented their respective organizations. Michael reminded everyone about the GraphQL spec membership Agreement, participation guidelines, contribution guide, and code of conduct, emphasizing that the meeting would be recorded and potentially summarized using AI. The group discussed a curated list of issues that were previously reviewed.

### Revising 'External' to 'Requires

The team discussed the use of the term "external" in their system, particularly in relation to the "requires" functionality. They agreed that "requires" was a more appropriate term than "external" in this context, as it better reflects the current design where arguments are exposed rather than needing to re-expose them. Pascal explained that with the current system, all necessary information is available for mapping, making the re-exposure of fields unnecessary. Martijn provided background on the original reasoning for using "external," which was based on an analogy with external declarations in C, but the team concluded that "partial" might be a better term for their specific use case.

### Interface Implementation Across Subgraphs

The team discussed a scenario involving two implementing types (B and C) and an interface type (A) across multiple subgraphs. They clarified that each subgraph would contain only a subset of fields from the interface, with type C implementing both fields A and B in one subgraph while type B implements only field A in another subgraph. Pascal explained that type C, which only contains data for field A, must be marked as external to satisfy the interface validation requirements, as it cannot resolve field B from its subgraph.

### GraphQL Interface Handling Discussion

The team discussed a technical issue related to the handling of interfaces and external data in GraphQL subgraphs. They explored how to handle cases where implementations of interfaces are split across different subgraphs, and debated whether a new directive was needed for this purpose. After considering various options, they decided to keep the existing "provides" directive and not introduce new functionality, citing prior art and potential breaking changes as reasons. The team agreed to close the issue and revisit it later if needed.

### Union Type Error Handling Strategy

The team discussed handling scenarios where an internal or inaccessible type is used in a union, focusing on error handling and runtime behavior. Sachin explained that customers preferred an error approach where subgraphs would not return certain types, resulting in a runtime error if they did. The team agreed on a composition warning with a runtime error, ensuring that warnings can be ignored but errors cannot be disabled. They also decided to avoid leaking specific type information in error messages, aiming for a generic error message indistinguishable from unknown types.

### GraphQL Shared Fields Consistency Issue

The team discussed a technical issue related to shared fields and subgraphs in a GraphQL system. They identified a problem where different choices of subgraphs could lead to non-intersecting sets of platform runtimes, violating the contract of shareable fields. Martijn and Michael explored the implications of this issue, with Martijn suggesting that the problem might be related to the way queries are planned and executed. Pascal raised a potential edge case involving multiple services and different types of data, but the team agreed that the core issue was about ensuring consistency when resolving shared fields across subgraphs.

### GraphQL Federation Validation Challenges

The team discussed issues with node interface validation and satisfiability rules in GraphQL Federation. Martijn and Michael agreed that having multiple node root fields in different subgraphs would be inefficient, suggesting instead to use a single entry point for ID decoding. Kamil explained a specific customer scenario where the issue occurred due to external annotations on IDs in different subgraphs, but noted that gateway implementations handle this by avoiding composition errors and instead returning informative messages about unresolved data.

### Nodes vs Lookups in Subgraphs

The discussion focused on the use of nodes and lookups in subgraphs, with Martijn and Michael exploring the differences between the two approaches. Michael shared insights from his conversation with Matt from Meta, noting that Facebook avoids specifying nodes in favor of lookups for cleaner query planning. They discussed the need for a semantic way to communicate implementing types, particularly in cases where shared ID spaces exist across different types. The conversation highlighted that while nodes are useful for certain use cases like client data refresh, lookups offer a more streamlined approach by eliminating backend complexity and providing immediate semantic field access.

### Shareable Fields Validation Discussion

The team discussed validation rules for shareable fields in interfaces, focusing on the requirement that the intersection of possible runtime types must be greater than zero. Sachin explained that this validation is intended to indicate whether the shareable directive is being used correctly, though it doesn't guarantee that different implementations will do the same thing at runtime. The team also considered a nested object type example where different services share a common type, concluding that this specific case doesn't require the query planner to pick between subgraphs since the path is already determined.
