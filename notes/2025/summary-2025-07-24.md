# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-07-24T15:59:44Z
- Meeting end: 2025-07-24T16:59:19Z
- Summary start: 2025-07-24T16:01:06Z
- Summary end: 2025-07-24T16:59:18Z

The meeting began with introductions and agenda setting, including a brief discussion about an upcoming GraphQL conference. The team then focused on implementing selection set syntax and type conditions in their GraphQL system, discussing various technical aspects including field requirements, validation rules, and the placement of type conditions. The conversation concluded with detailed discussions about the choice operator implementation, including how to handle type unions, selection sets, and data mapping, with the team agreeing to continue the discussion in Slack.

## Next Steps

- Michael to continue the discussion on the choice operator syntax and semantics in Slack
- Michael to develop a strong algorithm in the spec that describes how to gather up data
- Team to refine the grammar rules for the selection set syntax
- Team to clarify the semantics of the choice operator and how it relates to type conditions
- Team to define validation rules for selection sets with type conditions
- Team to consider allowing type conditions at the same level as the choice operator
- Team to explore options for indicating if type conditions need to be met or can be null
- Team to investigate how to handle cases where both type conditions are true

## Summary

### GraphQL Conference and Selection Set Discussion

The meeting began with introductions, where Michael, Pascal, Duckki, Martijn, and Sachin greeted each other. Michael announced the agenda, highlighting two main items: a 15-minute discussion on "Selection Set Map" and an issue review, with the option to add more topics if needed. The group briefly discussed the upcoming GraphQL conference, noting its proximity and location in San Francisco, and Martijn mentioned uncertainty about attending the GraphQL summit. Michael reminded attendees of the meeting's recording and the use of AI for summaries, and the conversation ended with a reminder of the GraphQL membership agreements and guidelines.

### Selection Set Syntax Implementation Discussion

The team discussed the implementation of selection set syntax, focusing on field requirements and validation rules. They agreed to start with simple cases and avoid encoding complex behaviors like null handling in the syntax, with Pascal suggesting such cases should be handled through arguments instead. Martijn and Pascal debated the need for a double question mark operator for nullable types, but decided to postpone this feature for a future version. The team also considered the complexity of type-specific side effects and discussed the possibility of requiring a common prefix for certain cases.

### Generic Type Specification Challenges

Michael, Martijn, and Pascal discussed the complexity of specifying generic types in their system. They debated the placement of type conditions, with Martijn suggesting they should be at the level of the choice operator rather than individual fields. Pascal checked the grammar support for their proposed syntax and found some limitations, particularly with the placement of generics in paths. The team agreed to further explore the syntax specifics after addressing the core issue.

### Choice Operator Design and Validation

The team discussed the syntax and semantics of a choice operator in their language, focusing on type conditions and validation. Martijn suggested restricting the choice operator to always have type conditions as its direct children, while Pascal and Michael expressed concerns about open vs. closed choices and the potential complexity of validation. They considered defining validation in terms of selection sets and discussed the need for precise syntax to avoid runtime exceptions. The conversation highlighted the challenges of implementing a choice mechanism that is both expressive and safe.

### GraphQL Selection Sets Implementation Challenges

The team discussed the implementation of GraphQL selection sets and type conditions, focusing on how to handle choices between different input types. Martijn and Pascal clarified that the choice operator isn't a true choice at execution time, but rather a way to define possible types that can be executed. Michael raised concerns about the need to make explicit choices for input data when dealing with one-off cases, as per the specification. The discussion highlighted the complexity of balancing GraphQL semantics with the need for input shaping, with no clear resolution on how to best implement this feature.

### GraphQL Choice Operator Implementation Discussion

The team discussed the implementation of a choice operator in their GraphQL algorithm, focusing on how to handle type conditions and data mapping. Michael and Martijn agreed that type conditions should be evaluated separately from the choice operator, with normal GraphQL selection set merging rules applying to the results. They determined that in one-off cases where multiple paths could return values, a choice needs to be made, but in normal cases, both paths can be extracted and mapped to the desired shape without requiring a choice operator. Pascal suggested fragment isolation as a potential solution, though the team didn't reach a final decision on whether it was necessary.

### GraphQL Choice Operator Implementation Discussion

The team discussed the implementation of a choice operator in GraphQL, focusing on how it handles type unions and selection sets. They debated the syntax and placement of the choice operator, with Pascal and Michael proposing different approaches. Martijn suggested allowing angle brackets before braces to indicate choices. The group agreed that the choice operator should be limited to the first object creation, but left open the question of how to handle cases where choices are not at the top level. They decided to continue the discussion in Slack and develop a strong algorithm for data gathering in the specification.
