# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-07-31T16:01:16Z
- Meeting end: 2025-07-31T17:04:59Z
- Summary start: 2025-07-31T16:01:43Z
- Summary end: 2025-07-31T17:04:51Z

The GraphQL Composite Schemas Working Group met to discuss ongoing work on field selection map syntax and test framework formats, with members sharing different approaches including YAML-based and single-file solutions. The team explored various aspects of test cases and schema compositions, including error handling and validation approaches, while discussing the benefits of using common formats across implementations. They also addressed challenges with enum values and lookup fields, and debated syntax options for one-off use cases and type conditions, with plans to continue these discussions in the next meeting.

## Next Steps

- Ducky to post example of test format in Slack chat and issue #195
- Michael to ping Stephen about Netflix's internal implementation testing format
- Michael to invite Andy to a future meeting
- Team to continue discussion on requires case syntax and type conditions in next week's meeting
- Team to evaluate algorithm for handling type conditions and field selection in requires case
- Team to decide on handling of invalid type conditions in one-off cases

## Summary

### GraphQL Working Group Meeting Introduction

The meeting began with introductions from Michael, Pascal, Shane, Martijn, and Duckki, who are all part of the GraphQL Composite Schemas Working Group. Michael noted that the agenda was initially empty but expected additional items to be added. The group discussed the continuation of last week's topic on field selection map syntax and Michael mentioned experimenting with different suggestions. Michael reminded everyone of the meeting guidelines, including the GraphQL Spec membership agreement and the use of AI for summaries, and the meeting was confirmed to be recorded on YouTube.

### Single-File GraphQL Test Framework

Duckki presented a test framework format that uses a single GraphQL file with separator annotations to define subgraph schemas, which he found useful for managing and debugging tests. Michael mentioned that a similar approach was being developed with the GraphQL Java team, using a YAML-based single file format to describe subgraphs and interactions for shared testing. Pascal noted that Duckki's format maintains the benefit of single-file convenience while preserving IDE features like intellisense.

### GraphQL Test Case Format Discussion

The team discussed the format for specifying test cases and schema compositions in the GraphQL composite schemas specification. Michael shared their current approach of using a YAML-based format to describe queries, subgraphs, and interactions, which Duckki noted is similar to the Apollo Federation team's approach using Rose code. The group agreed that a common format would be beneficial for defining test cases and contributing new tests, though they did not reach a final decision on the specific format to use.

### Test File Composition and Integration

The team discussed test files for composition and execution, focusing on error conditions and expected outcomes. Duckki explained that the tests primarily check for errors and hints, while Pascal emphasized the need to include the expected public schema in composition tests. They also discussed the benefits of using YAML format for tests, as it would allow for easier parsing across different implementations. The team considered integrating these tests into the fusion gateway, ensuring consistency across various implementations.

### Inline Validation Strategy Discussion

The team discussed inline hints and errors for validation, with Michael expressing interest in establishing this early on for implementers. Martijn supported adopting inline hints regardless of container format, as they wouldn't result in additional validation errors. Duckki confirmed there's no plugin integration yet but mentioned potential for future development. Michael suggested inviting Andy to the next meeting, noting the need for a different time due to his location in Sydney. The team also considered reaching out to Stephen and exploring how Netflix tests their implementation internally.

### Enum Handling Design Challenges

Michael and Martijn discussed the challenges of handling enum values in their syntax design, particularly regarding ambiguity and type resolution. They explored potential solutions, including qualified names and context-based disambiguation, but agreed that solving this issue should not compromise the overall design. Michael mentioned that Benjie suggested focusing on common cases for version one, while Michael remains open to exploring design solutions for enum handling. They also reflected on their original proposal and its purpose for simple one-offs.

### Query System Lookup Design Discussion

Michael and Martijn discussed the design of lookup and require fields in a query system. They explored how lookups differ from requires in terms of data selection and planning, with lookups allowing for more flexible key definitions. Shane raised a concern about ambiguous lookup fields, but Michael clarified that the current design is not ambiguous. They also discussed how lookups can be translated into multiple subgraph queries in the gateway while maintaining a clean user-facing syntax.

### Choice Operator for One-Off Syntax

The team discussed the syntax for one-off use cases in their system, focusing on the choice operator versus inferred semantics. Michael explained that while both approaches work technically, the choice operator provides better readability for one-off cases. Martijn raised concerns about handling nested one-offs and type conditions, but Michael confirmed that the current syntax handles these cases well. The team agreed to maintain the choice operator for one-offs while exploring options for requires cases, with Pascal suggesting it could allow more options to be hidden as internal IDs. They also discussed the complexity of handling type conditions and overlapping types in requires cases, which may require further refinement of the syntax.

### GraphQL Type Validation Strategies

The team discussed how to handle type conditions and input objects in GraphQL, focusing on validation and selection sets. Pascal and Martijn debated whether to throw exceptions or ignore invalid type conditions, with Pascal advocating for a more permissive approach that would allow invalid fields to be removed. Michael suggested following the GraphQL merging algorithm and injecting default values where applicable. The team agreed to continue the discussion in next week's meeting, as they did not reach a final decision.
