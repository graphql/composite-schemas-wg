# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-09-18T16:00:10Z
- Meeting end: 2025-09-18T17:03:30Z
- Summary start: 2025-09-18T16:00:40Z
- Summary end: 2025-09-18T17:01:07Z

The meeting focused on discussing GraphQL performance optimization challenges, including query planning, field deferment, and concurrency issues in federation. The team explored various solutions for handling slow fields, data duplication, and enum behavior across subgraphs, with different approaches being proposed including automatic deferring, directives, and manual schema configurations. The group agreed to gather more customer feedback on enum handling and documentation approaches, while also planning to create an appendix in the specification to describe optimization strategies and proposed solutions.

## Next Steps

- Mark to draft an appendix for the specification that describes the problem of slow field execution in federated GraphQL and proposes solutions .
- Michael to post the new defer spec in the Composite channel for team review.
- Michael to discuss with Steven and document Netflix's approach to enum handling in federated GraphQL.
- Michael to share the enum handling documentation with the team before the next meeting.
- Sachin to discuss the enum handling approach with Apollo colleagues and gather feedback, especially from customers.
- Kamil to share the enum handling documentation with his team for internal discussion.

## Summary

### GraphQL Edge Case Discussion

The meeting began with introductions and a reminder of the meeting's guidelines and recording policies. Michael outlined two agenda items: discussing a problem Mark presented at the conference and addressing email merging feedback. Mark explained a pull request (634) related to a GraphQL edge case, presenting two options: adding defer to eligible fields or using a manual schema directive for field parallelization. Pascal suggested a simpler approach involving fetching requirements quickly and deferring complex fetches lazily. The group agreed to further discuss these options and potentially revisit their chosen solution.

### Query Performance Optimization Challenges

Mark presented a problem with query performance where two slow fields in a selection set could not be optimized due to their independence and different subgraph locations. He explained that the optimal solution would be to call these fields in parallel, but current options either require deferring non-immediate fields or creating a new schema directive for query planner hints. Pascal suggested that the server could decide which fields to defer, with the source schema determining which chunks should be resolved together or as lazy dependencies, which would be particularly useful for frameworks like Hot Chocolate.

### Query Planning and Execution Proposal

The team discussed a new proposal for query planning and execution that addresses performance issues related to data duplication and server efficiency. Michael explained that Yakov and Rob developed a solution that de-duplicates data and allows for more efficient query execution by merging parts that don't need to be deferred. Martijn suggested adding more metadata to the spec to provide information about subgraph capabilities, such as support for query batching and async boundaries. The team agreed that while query planning and execution are implementation details, they should describe the interaction with defer in the spec. Michael mentioned that Benjie has made progress on capabilities for GraphQLAN and could present more information on this topic next week.

### GraphQL Federation Concurrency Solutions

The team discussed approaches to handling concurrency issues in GraphQL federation, with Mark proposing a "defer" approach as an ideal solution that would avoid the need for explicit directives. Martijn and Michael explored the possibility of using split schemas and subqueries, with Martijn noting that caching could be a use case for separate subqueries. Pascal suggested that the specification should acknowledge the execution challenges but allow implementers to choose their own solutions, similar to how the GraphQL spec handles implementation details. The team agreed that further discussion would be needed on caching and cost-related aspects, but they aimed to keep the specification flexible enough to accommodate different solutions.

### GraphQL Query Optimization Strategies

The team discussed implementing cost and performance optimization strategies for GraphQL queries, focusing on OpenTelemetry and query planning approaches. Kamil advocated for explicit handling of slow fields through directives and batch execution, while Michael and Pascal debated the merits of automatic layering versus static emission of cost data. The group agreed to create an appendix in the specification that would describe the problem and propose solutions, including both automatic deferring for new implementations and a directive-based approach for legacy systems. Mark volunteered to draft this appendix for further discussion.

### Enum Handling in GraphQL Subgraphs

The team discussed enum handling across subgraphs and services, focusing on the intersection approach proposed by Michael, which was previously considered but rejected due to potential runtime issues. Pascal explained that the current specification allows for exact matching only, with the flexibility to choose different approaches later without breaking changes. The team agreed with Netflix's approach of passing unknown enum values through and relying on clients to handle potential runtime errors, as it aligns with best practices in GraphQL to guard against future enum value additions. Martijn raised a concern about input enums, but Michael confirmed that subgraphs typically don't care about unknown input values.

### Federated System Input Behavior Discussion

Pascal and Michael discussed the use of intersection for input behavior in a federated system, emphasizing that outputs are not cared about when inputs are focused. Martijn raised concerns about the safety of intersection and backward compatibility, particularly regarding shared output types. Pascal explained that the assumption for convergence of enums across all subgraphs comes from the standpoint of shared libraries, similar to Netflix's approach. Sachin expressed unease with the current approach, suggesting it attempts to merge output and input enums, which may not be ideal.

### GraphQL Enum Handling Challenges

The team discussed challenges with enum handling in GraphQL, particularly around shared enums between subgraphs. Sachin expressed concerns about relying on implicit enum behavior, while Pascal and Michael noted that Netflix's approach involves manual intersection and loosening validation rules. The group agreed to gather more customer feedback through Apollo and analyze usage patterns, as the current spec proposal includes introducing an "inaccessible" feature for enum handling. Pascal highlighted a specific scenario where adding a new enum field could cause deployment issues if not properly managed, emphasizing the need for careful validation and implementation.

### Enum Behavior and Implementation Discussion

The team discussed the behavior of enums in their system, particularly focusing on how they handle input and output scenarios. Kamil expressed confusion about the current implementation, while Michael noted that the behavior changes when enums are moved from output to input. Martijn and Sachin explained that the behavior depends on how enums are used in the schema, rather than any explicit annotation. The team agreed to gather more feedback from colleagues and customers about the current implementation and its implications for backwards compatibility. They decided to document Netflix's current approach and discuss it further in the next meeting.
