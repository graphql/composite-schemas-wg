# Meeting Summary for Composite Schemas WG

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-10-16T16:00:47Z
- Meeting end: 2025-10-16T16:39:55Z
- Summary start: 2025-10-16T16:01:06Z
- Summary end: 2025-10-16T16:39:51Z

The meeting focused on discussing GraphQL Spec membership agreements and participation guidelines, followed by a detailed review of Sachin's proposal for simplifying enum merging in Apollo through input-only and output-only enum values. The team explored various implementation approaches and discussed how input/output definitions in subgraphs affect data validation and coercion rules, while also considering the implications for API schema design and backwards compatibility. The conversation ended with discussions about implementing API schema generation and introspection features, including potential standardization efforts and the importance of maintaining backwards compatibility with new GraphQL features.

## Next Steps

- Michael to find out the appetite within the TSC for including the enum merging proposal in the GraphQL core specification and talk to Lee about it.
- Michael to talk to Benjie about standardizing a route  for exposing the schema file through HTTP.
- Sachin to address any additional questions or edge cases about the enum merging proposal in the spec thread.
- Team to develop composition rules and warnings for cases where no input or output is possible in the enum merging proposal.
- Team to work on how to explain the enum merging proposal in simpler terms for documentation.

## Summary

### GraphQL Spec Membership Discussion

The meeting began with informal greetings and brief discussions about a recent summit. Michael then reminded everyone about the GraphQL Spec membership agreements, participation guidelines, and code of conduct. The group agreed to discuss Sachin's examples for enum merging, which Sachin reintroduced and shared on screen. They briefly discussed the proposal, but Sachin needed to refresh his memory on the details.

### Simplifying Enum Merging in Apollo

Sachin presented a proposal to simplify enum merging in Apollo by introducing input-only and output-only enum values, which would reduce errors and improve user experience. He explained the rules for implementing this system, including the creation of sets U and I for output and input positions respectively. Sachin also provided examples to demonstrate how the proposal would work in practice, focusing on subgraphs and the enforcement of expected rules for enum values.

### Enum Annotations in Input-Output Positions

Sachin explained a method for handling enum annotations in input and output positions, demonstrating how to compute sets based on usage patterns. Michael clarified that if an enum has no annotations, it is considered for both input and output, and asked about conflicting annotations, to which Sachin confirmed that conflicting annotations would also be considered for both positions, but only within the same subgraph. Pascal noted that if one subgraph defines an enum as input only and another as output only, the annotations would effectively cancel out, and discussed the need for implementations using supergraph schemas to store such metadata.

### Subgraph Input/Output Validation Rules

The team discussed how input/output definitions in subgraphs affect data validation and coercion rules. Sachin explained that if a field is defined as output-only in one subgraph but input-only in another, the executor would enforce the output-only definition during coercion, preventing runtime errors. They also discussed how shared fields with different input definitions across subgraphs would result in an empty input set in the merged schema, ensuring consistent behavior regardless of which subgraph is used.

### GraphQL Schema Composition Rules

The team discussed composition rules for GraphQL schemas, focusing on handling cases where input or output fields are not properly defined. They agreed that warnings should be implemented for transitional states, rather than immediate errors, to avoid disrupting migration or individual subgraph updates. Sachin explained that while this approach might increase runtime errors, it would reduce surprise cut-offs and make the system more user-friendly. Pascal suggested adding a note to the spec allowing optional validation of enum values, giving users the choice between strict enforcement and more lenient behavior.

### GraphQL Enum Extension Discussion

The team discussed extending the GraphQL specification to handle input and output enums more effectively, with Sachin and Michael agreeing that it could be implemented as a transitional state while remaining spec-compliant. Pascal raised concerns about how to explain this concept to users, and Kamil suggested framing it as encoding two separate enums that are then intersected and merged. Martijn inquired about the implications for Cojan, noting that most languages would need strict input validation, and the team discussed the pros and cons of duplicating enums versus using a more concise model.

### API Enum Schema Design Discussion

The team discussed API schema design, focusing on handling input-only and output-only enums. Sachin and Michael explored the possibility of generating separate input and output schemas, with Sachin noting potential backwards compatibility issues. Pascal suggested this could be implemented as an optional preprocessor feature. The group agreed that while input-only and output-only enums are beneficial, API designers would need to establish rules for naming these schemas. They concluded that the proposed approach would allow for flexible enum splitting while maintaining compatibility with existing systems.

### APA Schema Implementation Strategy

The team discussed the challenges and potential solutions for implementing APA schema generation and introspection in their system. Michael suggested getting the feature into the core specification, which could take about a year, but noted that implementing draft specifications can be faster. They agreed to explore standardizing a route for schema access, with Michael planning to talk to Benjie about involving the HTTP working group. The team also considered the benefits of providing a direct schema file endpoint, especially for tools and code generation, and discussed the importance of maintaining backwards compatibility with new GraphQL features.
