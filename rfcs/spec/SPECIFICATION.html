<!DOCTYPE html>
<!-- Built with spec-md https://spec-md.com -->
<html>
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1"><title>GraphQL Composite Schemas Spec</title>
<style>@media (prefers-color-scheme: light){:root{--color-foreground: #333333;--color-background: #ffffff;--color-light-grey: #ccc;--color-grey: #666666;--color-white: #fff;--color-link: #3b5998;--color-subsection-link: var(--color-foreground);--color-toc-link: var(--color-foreground);--color-toc-id: var(--color-link);--color-toggle-border: #bbc;--color-sidebar-background: #f0f0f0;--color-sidebar-viewing-link: #8b9;--color-sidebar-toggle-button: rgba(0, 0, 0, .7);--color-sidebar-shadow-inset: rgba(0, 0, 0, .05);--color-sidebar-shadow: rgba(0, 0, 0, .04);--color-sidebar-large-shadow: rgba(0, 0, 0, .08);--color-pre-background: #fafafa;--color-pre-border: #e9e9e9;--color-code-background: rgba(0, 0, 0, .03);--color-spec-todo: var(--color-grey);--color-spec-example: #fafaff;--color-spec-example-border: #bbbbff;--color-spec-counter-example: #fffafa;--color-spec-counter-border: #ffbbbb;--color-spec-counter-example-link: #98593b;--color-spec-added-border: #396;--color-spec-removed-border: #933;--color-spec-prose: var(--color-grey);--color-spec-quantifier-list: var(--color-link);--color-spec-quantifier-optional: #83238e;--color-spec-condition: #1c7758;--color-spec-param: var(--color-grey);--color-spec-rx: var(--color-foreground);--color-spec-note-border: #f4e925;--color-spec-note-background: #fefef3;--color-spec-note-first-link: #6c6613;--color-source-link: var(--color-light-grey);--color-table-header: #f9f9f9;--color-table-header-border: #d0d0d0;--color-token-inserted: hsla(241, 71%, 34%, .69);--color-token-deleted: hsla(324, 92%, 33%, .74);--color-inserts-background: rgba(0, 200, 30, .08);--color-deletions-background: rgba(200, 0, 0, .08);--selection-background-color: #cacee0;--selection-background-color-link: #f0babe}.selection-link:hover{--selection-background-color: #3b5998}}@media (prefers-color-scheme: dark){:root{--color-foreground: #b6b6b6;--color-background: #262626;--color-light-grey: #373737;--color-grey: #828282;--color-white: rgb(29, 29, 29);--color-link: #89b7da;--color-subsection-link: var(--color-foreground);--color-toc-link: var(--color-foreground);--color-toc-id: var(--color-link);--color-toggle-border: #bbc;--color-sidebar-background: #323232;--color-sidebar-viewing-link: #8b9;--color-sidebar-toggle-button: rgba(220, 220, 220, .7);--color-sidebar-shadow-inset: rgba(0, 0, 0, .05);--color-sidebar-shadow: rgba(0, 0, 0, .04);--color-sidebar-large-shadow: rgba(0, 0, 0, .08);--color-pre-background: #2e2e2e;--color-pre-border: #3a3a3a;--color-code-background: rgba(41, 41, 41, .03);--color-spec-todo: var(--color-grey);--color-spec-example: #2b2b35;--color-spec-example-border: #4d4d6d;--color-spec-counter-example: #322828;--color-spec-counter-border: #664040;--color-spec-counter-example-link: #ff702d;--color-spec-added-border: #396;--color-spec-removed-border: #933;--color-spec-prose: var(--color-grey);--color-spec-quantifier-list: var(--color-link);--color-spec-quantifier-optional: #c689ce;--color-spec-condition: #6fa889;--color-spec-param: var(--color-grey);--color-spec-rx: var(--color-foreground);--color-spec-note-border: #605e39;--color-spec-note-background: #303028;--color-spec-note-first-link: #f0e330;--color-source-link: var(--color-grey);--color-table-header: #373737;--color-table-header-border: #525252;--color-token-inserted: hsla(241, 63%, 70%, .69);--color-token-deleted: hsla(325, 64%, 67%, .74);--color-inserts-background: rgba(0, 200, 30, .08);--color-deletions-background: rgba(200, 0, 0, .08);--selection-background-color: #656565;--selection-background-color-link: #f0babe}.selection-link:hover{--selection-background-color: #829edb}}:root{color:var(--color-foreground);background-color:var(--color-background);font-family:var(--font-family);font-size:15px;line-height:1.5;--mono-font-size: 13px;--indent: 1rem;--list-indent: 1.5rem;--dfn-indent: 0rem;--font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;--font-family-monospace: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace}@media (min-width: 720px){:root{font-size:17px;--mono-font-size: 15px;--indent: 2rem;--list-indent: 2rem;--dfn-indent: 2rem}}body{margin:3rem 0 3rem}article{margin:0 1rem}@media (min-width: 720px){body{margin:6rem auto 3rem;max-width:800px;padding-left:75px;padding-right:clamp(0px,calc((100vw - 800px) * .25),75px)}}.source-link{display:none}@media screen and (min-width: 720px){.source-link{display:block;position:absolute;width:18px;fill:var(--color-source-link);opacity:.3}.source-link:hover{opacity:1}}.outdated-selection-link,.selection-link{position:absolute;display:block;color:var(--color-white);background:var(--selection-background-color);border-radius:4px;font-size:36px;height:23px;line-height:48px;text-align:center;text-decoration:none;width:25px;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.outdated-selection-link:hover,.selection-link:hover{text-decoration:none}.outdated-selection-link:before,.selection-link:before{border:5px solid transparent;content:"";height:0;margin-top:-5px;margin-right:-5px;position:absolute;right:1px;top:50%;width:0}@media (max-width: 719px){.outdated-selection-link:before,.selection-link:before{border-bottom-color:var(--selection-background-color);border-top:0;right:50%;top:1px}}@media (min-width: 720px){.outdated-selection-link:before,.selection-link:before{border-left-color:var(--selection-background-color);border-right:0;right:1px;top:50%}}.outdated-selection-link{background:var(--selection-background-color-link);font-size:21px;font-weight:800;line-height:27px}.outdated-selection-link:hover:after{content:"This selection content has changed since this link was created.";font:9pt/11pt var(--font-family);position:absolute;display:block;white-space:nowrap;padding:2px 5px 1px;top:-20px;background:black;color:var(--color-white)}a{color:var(--color-link);text-decoration:none}a:hover{text-decoration:underline}img{max-width:100%}dl{margin:1rem 0 1rem var(--dfn-indent)}dd{margin:.25em 0 .5em var(--indent)}dd+dd{margin-top:1rem}dfn,.spec-ref{font-style:italic}dfn>a,.spec-ref>a{color:inherit}h1,h2,h3,h4,h5,h6{font-weight:bold;margin:3em 0 1em;position:relative}@media (min-width: 720px){header>h1{margin:6em 0 3em}}h1{font-size:1.5em;margin-top:5em}h2,h3{font-size:1.25em}h4,h5,h6{font-size:1em}section{padding-top:1rem;margin-top:-1rem}section.subsec>h6{margin-top:2em}section.subsec>h6>a{color:var(--color-subsection-link)}section .spec-secid{margin-right:1ex}@media (min-width: 720px){section .spec-secid{position:absolute;right:100%;text-align:right;white-space:nowrap}}footer{font-size:75%;opacity:.5;text-align:center;margin-top:12rem}.spec-toc{margin:1rem 0 3rem}.spec-toc .title{content:"Contents";display:block;font-weight:bold;margin:5em 0 1em}.spec-toc .spec-secid{margin-right:1ex}.spec-toc ol{list-style:none;padding-left:0;margin-top:0;margin-bottom:0}.spec-toc ol ol{list-style:none;padding-left:2ex;margin-bottom:.25em}.spec-toc li{position:relative;padding:5px 0 0 30px;margin:-5px 0 0 -30px}.spec-toc a{color:var(--color-toc-link)}.spec-toc a:hover{text-decoration:none}.spec-toc a .spec-secid{color:var(--color-toc-id)}.spec-toc a:hover .spec-secid{text-decoration:underline}.spec-toc .toggle{display:none}.spec-toc .toggle+label{cursor:pointer;left:6px;opacity:1;padding:5px 6px 5px 7px;position:absolute;top:6px;transform:rotate(0deg);transition:all .18s ease-in-out}.spec-toc .toggle+label:after{border-color:transparent transparent transparent var(--color-toggle-border);border-style:solid;border-width:6px 0 6px 7px;content:" ";display:block;height:0;width:0}@media (pointer: fine){.spec-toc .toggle+label{left:10px;padding:3px 5px 3px 6px;top:8px}}.spec-toc .toggle:checked+label{transform:rotate(90deg)}@media (hover: hover){.spec-toc li:not(:hover)>.toggle:checked+label{opacity:0}}.spec-toc .toggle:not(:checked)~ol{max-height:0;overflow:hidden;margin:0}.spec-sidebar-toggle{display:none}.spec-sidebar-toggle+label>.spec-sidebar-button{position:fixed;right:0;top:0;padding:10px 15px;font-size:30px;color:var(--color-sidebar-toggle-button);z-index:2;cursor:pointer;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.spec-sidebar-toggle:checked+label:after{content:"";position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0}.spec-sidebar{display:none;position:fixed;right:0;top:0;width:min(320px,calc(100vw - 48px));font-size:14px;line-height:1.75;overflow-y:scroll;height:100%;padding:0 0 5rem 30px;box-sizing:border-box;background:var(--color-sidebar-background);box-shadow:inset 1px 0 var(--color-sidebar-shadow-inset),-4px 0 8px -2px var(--color-sidebar-shadow);overscroll-behavior:contain}.spec-sidebar{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.spec-sidebar-toggle:checked~.spec-sidebar{display:block}.spec-sidebar .viewing>a:after{color:var(--color-sidebar-viewing-link);content:"\2022";margin-left:1ex}@media (min-width: 1220px){.spec-sidebar-toggle+label{display:none}.spec-sidebar{display:block;box-shadow:inset 1px 0 var(--color-sidebar-shadow-inset),inset 4px 0 8px -2px var(--color-sidebar-large-shadow)!important}body{padding-right:345px}}.spec-note{background:var(--color-spec-note-background);border-left:solid 4px var(--color-spec-note-border);margin:1rem -1rem;min-width:70vw;padding:8px 1rem 12px calc(1rem - 4px);width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}@media (min-width: 720px){.spec-note{min-width:416px}}.spec-note>a:first-child{color:var(--color-spec-note-first-link);display:block;font:italic 11pt/18pt var(--font-family);opacity:.6;user-select:none}.spec-todo{color:var(--color-spec-todo);margin:1em 0 1em 5em;min-height:1em}.spec-todo::before{content:"todo";display:block;float:left;margin-left:-5em;text-transform:uppercase}.spec-index ol{list-style-type:none;margin:0 0 0 var(--indent);padding:0;column-width:210px;column-gap:var(--indent)}.spec-index ol li{width:min-content;white-space:nowrap}pre,code{font-family:var(--font-family-monospace);font-size:var(--mono-font-size);font-weight:inherit}code{background:var(--color-code-background);margin:-2px -1px;padding:3px 3px;white-space:pre-wrap}pre>code{background:none;font-weight:inherit;margin:0;padding:0;white-space:pre}pre{background:var(--color-pre-background);border-left:solid 4px var(--color-pre-border);margin:1rem -1rem;min-width:70vw;padding:12px 1rem 12px calc(1rem - 4px);width:-moz-fit-content;width:-webkit-fit-content;width:fit-content;max-width:calc(100vw - 2rem);overflow-y:auto}@media (min-width: 720px){pre{min-width:40ch}}.spec-example{background:var(--color-spec-example);border-left:solid 4px var(--color-spec-example-border);padding-top:8px}.spec-counter-example{background:var(--color-spec-counter-example);border-left:solid 4px var(--color-spec-counter-border);padding-top:8px}.spec-example>a,.spec-counter-example>a{display:block;font:italic 11pt/18pt var(--font-family);opacity:.6;user-select:none}.spec-counter-example>a{color:var(--color-spec-counter-example-link)}table{border-collapse:collapse}th{background-color:var(--color-table-header)}td,th{border:1px solid var(--color-table-header-border);padding:.4em;vertical-align:baseline}ol,ul{padding-left:var(--list-indent)}li>ol,li>ul{margin-top:.25em;margin-bottom:.5em}li+li{margin-top:.25em}li.task{list-style-type:none;position:relative}li.task>input:first-child{margin-left:0;position:absolute;transform:translateX(calc(-100% - 1ch))}ins{background-color:var(--color-inserts-background);text-decoration:none}del{background-color:var(--color-deletions-background)}.spec-added,.spec-removed{border-left:4px solid;margin-left:-18px;padding-left:14px}.spec-added{border-color:var(--color-spec-added-border)}.spec-removed{border-color:var(--color-spec-removed-border);text-decoration:line-through}.spec-keyword{font-weight:bold}.spec-string{font-family:var(--font-family-monospace);font-size:85%;white-space:pre}var{font-style:italic}*[data-name]{transition:.15s background ease-out;border-radius:2px;padding:0 3px;margin:0 -3px}.spec-semantic,.spec-algo{margin:1rem 0 1rem var(--dfn-indent)}.spec-semantic>.spec-nt::after,.spec-algo>.spec-call:first-child::after{content:":";font-style:normal;font-weight:bold;margin-left:1ex}.spec-semantic ol,.spec-semantic ol ol ol ol,.spec-algo ol,.spec-algo ol ol ol ol{list-style-type:decimal}.spec-semantic ol ol,.spec-semantic ol ol ol ol ol,.spec-algo ol ol,.spec-algo ol ol ol ol ol{list-style-type:lower-alpha}.spec-semantic ol ol ol,.spec-semantic ol ol ol ol ol ol,.spec-algo ol ol ol,.spec-algo ol ol ol ol ol ol{list-style-type:lower-roman}.spec-call>a{color:inherit}.spec-production{margin:1rem 0 1rem var(--dfn-indent)}.spec-production>.spec-nt::after{content:":";font-style:normal;font-weight:bold;margin:0 1ex}.spec-semantic.d2>.spec-nt::after,.spec-production.d2>.spec-nt::after{content:"::"}.spec-semantic.d3>.spec-nt::after,.spec-production.d3>.spec-nt::after{content:":::"}.spec-production>.spec-rhs{line-height:1.1;margin:.25em 0 .5em calc(2 * var(--indent));text-indent:calc(-1 * var(--indent))}.spec-semantic>.spec-rhs{display:inline-block;text-indent:calc(-1 * var(--indent));margin-left:calc(1ex + var(--indent))}.spec-rhs>*{text-indent:0}.spec-oneof{display:inline}.spec-oneof::before{content:"one of";font-style:normal;font-weight:bold}.spec-oneof-grid{max-width:calc(100vw - 2rem);overflow:auto;margin:-1ex -1rem;padding:1ex 1rem}.spec-oneof-grid>table{margin-left:var(--indent)}.spec-oneof .spec-rhs{border:none;margin:0;padding:0 0 0 1rem;vertical-align:baseline;white-space:pre}.spec-oneof .spec-rhs:first-child{padding:0}.spec-rhs .spec-constrained:not(:first-child),.spec-rhs .spec-quantified:not(:first-child),.spec-rhs .spec-nt:not(:first-child),.spec-rhs .spec-t:not(:first-child),.spec-rhs .spec-rx:not(:first-child),.spec-rhs .spec-prose:not(:first-child),.spec-rhs .spec-empty:not(:first-child),.spec-rhs .spec-lookahead:not(:first-child){margin-left:1ex;display:inline-block}.spec-condition{font-size:85%}.spec-condition::before{content:"[if "}.spec-condition.not::before{content:"[if not "}.spec-condition::after{content:"]"}.spec-empty,.spec-prose{color:var(--color-spec-prose)}.spec-nt{font-style:italic}.spec-nt>a{color:inherit}.spec-quantifiers,.spec-params{font-size:65%;font-style:normal;vertical-align:sub}.spec-quantifier.list{color:var(--color-spec-quantifier-list)}.spec-quantifier.optional{color:var(--color-spec-quantifier-optional)}.spec-params,.spec-condition{color:var(--color-spec-condition)}.spec-params::before{content:"["}.spec-params::after{content:"]"}.spec-quantifier:not(:last-child)::after,.spec-param:not(:last-child)::after{color:var(--color-spec-param);content:", "}.spec-param.conditional::before{content:"?"}.spec-param.negated::before{content:"!"}.spec-t,.spec-rx{color:var(--color-spec-rx);font-family:var(--font-family-monospace);font-weight:bold}.spec-butnot::before{color:var(--color-grey);content:"but not";font-family:var(--font-family);font-weight:normal;margin-right:1ex}.spec-butnot>*:not(:first-child)::before{color:var(--color-grey);content:"or";font-family:var(--font-family);font-weight:normal;margin-right:1ex}.spec-rhs .spec-oneof::before,.spec-rhs .spec-butnot::before{margin-left:1ex}.spec-lookahead>*{margin:0!important}.spec-lookahead>*:not(:first-child)::before{color:var(--color-grey);content:", ";font-family:var(--font-family);font-style:normal;font-weight:normal}.spec-lookahead::before{color:var(--color-grey);content:"[lookahead = ";font-family:var(--font-family);font-style:normal;font-weight:normal}.spec-lookahead.not::before{content:"[lookahead \2260  "}.spec-lookahead.set::before{content:"[lookahead \2208  {";margin-right:0}.spec-lookahead.set.not::before{content:"[lookahead \2209  {"}.spec-lookahead.ntset::before{content:"[lookahead \2208  ";margin-right:0}.spec-lookahead.ntset.not::before{content:"[lookahead \2209  "}.spec-lookahead::after{color:var(--color-grey);content:"]"}.spec-lookahead.set::after{content:"}]"}code[class*=language-],pre[class*=language-]{color:var(--color-prism-foreground);background:none;text-shadow:0 1px var(--color-prism-text-shadow);font-family:var(--font-family-monospace);font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection{text-shadow:none;background:var(--color-prism-background)}pre[class*=language-]::selection,pre[class*=language-] ::selection,code[class*=language-]::selection,code[class*=language-] ::selection{text-shadow:none;background:var(--color-prism-background)}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:var(--color-prism-block-background)}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.atrule,.token.attr-value,.token.keyword,.token.property,.token.selector,.token.attr-name,.token.builtin,.token.entity,.token.url,.token.inserted{color:var(--color-token-inserted);background:none}.token.tag,.token.boolean,.token.number,.token.string,.token.char,.token.constant,.token.symbol,.token.regex,.token.important,.token.variable,.token.function,.token.class-name,.token.deleted{color:var(--color-token-deleted)}.token.comment,.token.prolog,.token.doctype,.token.cdata,.token.description{color:inherit;opacity:.3}.token.punctuation{color:inherit;opacity:.5}.token.operator,.token.namespace{color:inherit;opacity:.7}</style>
<script>(function(){var r,a=[];document.addEventListener("readystatechange",function(){document.readyState==="interactive"&&u()});function u(){var n=document.querySelector('label[for="spec-sidebar-toggle"]');n.addEventListener("scroll",o),n.addEventListener("touchmove",o);function o(d){d.preventDefault()}for(var t=document.getElementsByTagName("section"),e=0;e<t.length;e++)t[e].getAttribute("secid")&&a.push(t[e]);var i=window.scrollY,c=!1;window.addEventListener("scroll",function(d){i=window.scrollY,c||(c=!0,window.requestAnimationFrame(function(){s(i),c=!1}))})}function s(n){for(var o=n+document.documentElement.clientHeight/4,t,e=a.length-1;e>=0;e--)if(a[e].offsetTop<o){t=a[e];break}var i=t&&t.getAttribute("secid");i!==r&&(r&&l(r,!1),i&&l(i,!0),r=i)}function l(n,o){document.getElementById("_sidebar_"+n).className=o?"viewing":"";for(var t=n.split(".");t.length;){var e=document.getElementById("_toggle_"+t.join("."));e&&(e.checked=o),t.pop()}}s(window.scrollY);})();</script>
<script>(function(){var n=document.getElementsByTagName("style")[0].sheet,e;function u(){e&&(n.deleteRule(e),e=void 0)}function d(t){u(),e=n.insertRule('*[data-name="'+t+'"] { background: rgba(230,215,0,0.12); }',n.cssRules.length)}document.documentElement.addEventListener("mouseover",function(t){var a=t.target.attributes["data-name"];a&&d(a.value)});document.documentElement.addEventListener("mouseout",u);})();</script>
<script>(function(){var R="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",o,p,r,g;document.addEventListener("selectionchange",E);window.addEventListener("resize",C);window.addEventListener("hashchange",x);window.addEventListener("load",x);function S(n){y(new URL(n.target.href))}function x(){y(window.location)}function y(n){var e=n.hash.match(/^#sel-([A-Za-z0-9-_]+)$/);if(!!e){g=e[1],r=k(g);var t=r.getBoundingClientRect(),d=Math.max(20,Math.floor((window.innerHeight-t.height)*.4));window.scrollTo(0,window.scrollY+t.y-d);var c=document.getSelection();c.empty(),c.addRange(r),C()}}function E(n){var e=document.getSelection();if(e.isCollapsed)o&&(o.parentNode.removeChild(o),o=null);else{var t=e.getRangeAt(0);(!r||t.compareBoundaryPoints(Range.START_TO_START,r)!==0||t.compareBoundaryPoints(Range.END_TO_END,r)!==0)&&(r=t,g=B(r),C())}}function C(){if(!!r){p||(p=document.getElementsByTagName("article")[0]),o||(o=document.createElement("a"),document.body.appendChild(o)),o.href="#sel-"+g,o.onclick=S,o.className=r.isOutdated?"outdated-selection-link":"selection-link",o.innerText=r.isOutdated?"!":"\u201F";var n=window.innerWidth<720,e=r.getBoundingClientRect();if(n)o.style.left=Math.floor(e.x+e.width/2+window.scrollX-13)+"px",o.style.top=Math.floor(e.bottom+window.scrollY+10)+"px";else{var t=p.getBoundingClientRect().x;o.style.left=Math.floor(t+window.scrollX-37)+"px",o.style.top=Math.floor(e.y+window.scrollY-3)+"px"}}}function B(n){var e="",t=N(n.startContainer),d=N(n.endContainer),c=M(t,d);return l(c),l(t.slice(c.length).concat(n.startOffset)),l(d.slice(c.length).concat(n.endOffset)),i(L(n.toString())),e;function i(a){do e+=R[a&31|(a>31?32:0)],a>>=5;while(a>0)}function l(a){i(a.length);for(var h=0;h<a.length;h++)i(a[h])}}function k(n){for(var e=new Array(64),t=0;t<64;t++)e[R.charCodeAt(t)]=t;var d=0,c=m(),i=m(),l=m(),a=w(),h=i.pop(),P=O(c.concat(i)),T=l.pop(),A=O(c.concat(l)),u=document.createRange();return u.setStart(P,h),u.setEnd(A,T),u.isOutdated=a!==void 0&&a!==L(u.toString()),u;function w(){for(var s=0,v=0;d<n.length;){var f=e[n.charCodeAt(d++)];if(s|=(f&31)<<v,v+=5,f<32)return s}}function m(){var s=w();if(s!=null){for(var v=new Array(s),f=0;f<s;f++)v[f]=w();return v}}}function N(n){for(var e=[];n!=document.body;){var t=n.parentNode;e.push(Array.prototype.indexOf.call(t.childNodes,n)),n=t}return e.reverse()}function O(n){for(var e=document.body,t=0;t<n.length&&e;t++)e=e.childNodes[n[t]];return e}function M(n,e){for(var t=0;t<n.length&&t<e.length&&n[t]===e[t];)t++;return n.slice(0,t)}function L(n){for(var e=2166136261,t=0;t<n.length;++t)e^=n.charCodeAt(t),e+=(e<<1)+(e<<4)+(e<<7)+(e<<8)+(e<<24);return(e>>15^e)&32767}})();</script>
</head>
<body><article>
<header>
<h1>GraphQL Composite Schemas Spec</h1>
<section id="intro">
<section id="sec-Introduction" class="subsec">
<h6><a href="#sec-Introduction" title="link to this subsection">Introduction</a></h6>
<p>The GraphQL Composite Schemas introduces a comprehensive specification for creating distributed GraphQL systems that seamlessly merges multiple GraphQL schemas. This specification describes the process of composing a federated GraphQL schema and outlines algorithms for executing GraphQL queries on the federated schema effectively by using query plans. This specifcation was origially created by ChilliCream and was transfered to the GraphQL foundation.</p>
<p>The GraphQL Foundation was formed in 2019 as a neutral focal point for organizations who support the GraphQL ecosystem, and the GraphQL Specification Project was established also in 2019 as the Joint Development Foundation Projects, LLC, GraphQL Series.</p>
<p>If your organization benefits from GraphQL, please consider becoming a member and helping us to sustain the activities that support the health of our neutral ecosystem.</p>
<p>The GraphQL Specification Project has evolved and may continue to evolve in future editions of this specification. Previous editions of the GraphQL specification can be found at permalinks that match their release tag. The latest working draft release can be found at https://spec.graphql.org/draft.</p>
</section>
<section id="sec-Copyright-Notice" class="subsec">
<h6><a href="#sec-Copyright-Notice" title="link to this subsection">Copyright Notice</a></h6>
<p>Copyright © 2019-present, GraphQL contributors</p>
<p>THESE MATERIALS ARE PROVIDED &ldquo;AS IS&rdquo;. The parties expressly disclaim any warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to the materials. The entire risk as to implementing or otherwise using the materials is assumed by the implementer and user. IN NO EVENT WILL THE PARTIES BE LIABLE TO ANY OTHER PARTY FOR LOST PROFITS OR ANY FORM OF INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER FROM ANY CAUSES OF ACTION OF ANY KIND WITH RESPECT TO THIS DELIVERABLE OR ITS GOVERNING AGREEMENT, WHETHER BASED ON BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, AND WHETHER OR NOT THE OTHER MEMBER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</section>
<section id="sec-Licensing" class="subsec">
<h6><a href="#sec-Licensing" title="link to this subsection">Licensing</a></h6>
<p>The GraphQL Specification Project is made available by the <a href="https://www.jointdevelopment.org/">Joint Development Foundation</a>. The current <a href="https://github.com/graphql/graphql-wg">Working Group</a> charter, which includes the IP policy governing all working group deliverables (including specifications, source code, and datasets) may be found at <a href="https://technical-charter.graphql.org">https://technical-charter.graphql.org</a>.</p>
<p>Currently, the licenses governing GraphQL Specification Project deliverables are:</p>
<table>
<thead>
<tr>
<th>Deliverable</th>
<th>License</th>
</tr>
</thead>
<tbody>
<tr>
<td>Specifications</td>
<td><a href="https://www.openwebfoundation.org/the-agreements/the-owf-1-0-agreements-granted-claims/owfa-1-0">Open Web Foundation Agreement 1.0 (Patent and Copyright Grants)</a></td>
</tr>
<tr>
<td>Source code</td>
<td><a href="https://opensource.org/licenses/MIT">MIT License</a></td>
</tr>
<tr>
<td>Data sets</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a></td>
</tr>
</tbody>
</table>
</section>
<section id="sec-Conformance" class="subsec">
<h6><a href="#sec-Conformance" title="link to this subsection">Conformance</a></h6>
<p>A conforming implementation of GraphQL must fulfill all normative requirements. Conformance requirements are described in this document via both descriptive assertions and key words with clearly defined meanings.</p>
<p>The key words &ldquo;MUST&rdquo;, &ldquo;MUST NOT&rdquo;, &ldquo;REQUIRED&rdquo;, &ldquo;SHALL&rdquo;, &ldquo;SHALL NOT&rdquo;, &ldquo;SHOULD&rdquo;, &ldquo;SHOULD NOT&rdquo;, &ldquo;RECOMMENDED&rdquo;, &ldquo;MAY&rdquo;, and &ldquo;OPTIONAL&rdquo; in the normative portions of this document are to be interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">IETF RFC 2119</a>. These key words may appear in lowercase and still retain their meaning unless explicitly declared as non-normative.</p>
<p>A conforming implementation of GraphQL may provide additional functionality, but must not where explicitly disallowed or would otherwise result in non-conformance.</p>
</section>
<section id="sec-Conforming-Algorithms" class="subsec">
<h6><a href="#sec-Conforming-Algorithms" title="link to this subsection">Conforming Algorithms</a></h6>
<p>Algorithm steps phrased in imperative grammar (e.g. &ldquo;Return the result of calling resolver&rdquo;) are to be interpreted with the same level of requirement as the algorithm it is contained within. Any algorithm referenced within an algorithm step (e.g. &ldquo;Let completedResult be the result of calling CompleteValue()&rdquo;) is to be interpreted as having at least the same level of requirement as the algorithm containing that step.</p>
<p>Conformance requirements expressed as algorithms can be fulfilled by an implementation of this specification in any way as long as the perceived result is equivalent. Algorithms described in this document are written to be easy to understand. Implementers are encouraged to include equivalent but optimized implementations.</p>
<p>See <a href="#sec-Appendix-Notation-Conventions">Appendix A</a> for more details about the definition of algorithms and other notational conventions used in this document.</p>
</section>
<section id="sec-Non-Normative-Portions" class="subsec">
<h6><a href="#sec-Non-Normative-Portions" title="link to this subsection">Non-Normative Portions</a></h6>
<p>All contents of this document are normative except portions explicitly declared as non-normative.</p>
<p>Examples in this document are non-normative, and are presented to aid understanding of introduced concepts and the behavior of normative portions of the specification. Examples are either introduced explicitly in prose (e.g. &ldquo;for example&rdquo;) or are set apart in example or counter-example blocks, like this:</p>
<pre id="example-fed99" class="spec-example"><a href="#example-fed99">Example № 1</a><code>This is an example of a non-normative example.
</code></pre>
<pre id="example-881bd" class="spec-counter-example"><a href="#example-881bd">Counter Example № 2</a><code>This is an example of a non-normative counter-example.
</code></pre>
<p>Notes in this document are non-normative, and are presented to clarify intent, draw attention to potential edge-cases and pit-falls, and answer common questions that arise during implementation. Notes are either introduced explicitly in prose (e.g. &ldquo;Note: &ldquo;) or are set apart in a note block, like this:</p>
<div id="note-c0129" class="spec-note">
<a href="#note-c0129">Note</a>
This is an example of a non-normative note.</div>
</section>
</section>
<nav class="spec-toc">
<div class="title">Contents</div>
<ol>
<li><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a><ol>
<li><a href="#sec-Overview.Entities"><span class="spec-secid">1.1</span>Entities</a></li>
<li><a href="#sec-Keys"><span class="spec-secid">1.2</span>Keys</a></li>
</ol>
</li>
<li><a href="#sec-Composition"><span class="spec-secid">2</span>Composition</a><ol>
<li><a href="#sec-Directives"><span class="spec-secid">2.1</span>Directives</a><ol>
<li><a href="#sec-Directives.Entities"><span class="spec-secid">2.1.1</span>Entities</a><ol>
<li><a href="#sec--entityResolver"><span class="spec-secid">2.1.1.1</span>@entityResolver</a></li>
<li><a href="#sec--is"><span class="spec-secid">2.1.1.2</span>@is</a></li>
</ol>
</li>
<li><a href="#sec-Shared-Data"><span class="spec-secid">2.1.2</span>Shared Data</a><ol>
<li><a href="#sec--shareable"><span class="spec-secid">2.1.2.1</span>@shareable</a></li>
<li><a href="#sec--require"><span class="spec-secid">2.1.2.2</span>@require</a></li>
<li><a href="#sec--provides"><span class="spec-secid">2.1.2.3</span>@provides</a></li>
<li><a href="#sec--external"><span class="spec-secid">2.1.2.4</span>@external</a></li>
<li><a href="#sec--override"><span class="spec-secid">2.1.2.5</span>@override</a></li>
</ol>
</li>
<li><a href="#sec-Reshaping"><span class="spec-secid">2.1.3</span>Reshaping</a><ol>
<li><a href="#sec--internal"><span class="spec-secid">2.1.3.1</span>@internal</a></li>
</ol>
</li>
<li><a href="#sec-SchemaCoordinate"><span class="spec-secid">2.1.4</span>SchemaCoordinate</a></li>
</ol>
</li>
<li><a href="#sec-Validate"><span class="spec-secid">2.2</span>Validate</a><ol>
<li><a href="#sec-Types"><span class="spec-secid">2.2.1</span>Types</a><ol>
<li><a href="#sec-Semantical-Equvalence"><span class="spec-secid">2.2.1.1</span>Semantical Equvalence</a></li>
</ol>
</li>
<li><a href="#sec-Validate.Composite-Types"><span class="spec-secid">2.2.2</span>Composite Types</a><ol>
<li><a href="#sec-Field-Types-Mergable"><span class="spec-secid">2.2.2.1</span>Field Types Mergable</a></li>
<li><a href="#sec-Argument-Types-Mergable"><span class="spec-secid">2.2.2.2</span>Argument Types Mergable</a></li>
<li><a href="#sec-Arguments-Mergable"><span class="spec-secid">2.2.2.3</span>Arguments Mergable</a></li>
<li><a href="#sec-Required-Arguments-Cannot-Be-Internal"><span class="spec-secid">2.2.2.4</span>Required Arguments Cannot Be Internal</a></li>
<li><a href="#sec-Public-Fields-Cannot-Reference-Internals"><span class="spec-secid">2.2.2.5</span>Public Fields Cannot Reference Internals</a></li>
</ol>
</li>
<li><a href="#sec-Object-Types"><span class="spec-secid">2.2.3</span>Object Types</a><ol>
<li><a href="#sec-Empty-Merged-Object-Type"><span class="spec-secid">2.2.3.1</span>Empty Merged Object Type</a></li>
</ol>
</li>
<li><a href="#sec-Input-Object-Types"><span class="spec-secid">2.2.4</span>Input Object Types</a><ol>
<li><a href="#sec-Input-Field-Types-Mergable"><span class="spec-secid">2.2.4.1</span>Input Field Types Mergable</a></li>
<li><a href="#sec-Input-With-Different-Fields"><span class="spec-secid">2.2.4.2</span>Input With Different Fields</a></li>
<li><a href="#sec-Empty-Merged-Input-Object-Type"><span class="spec-secid">2.2.4.3</span>Empty Merged Input Object Type</a></li>
<li><a href="#sec-Input-Field-Default-Mismatch"><span class="spec-secid">2.2.4.4</span>Input Field Default Mismatch</a></li>
<li><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals"><span class="spec-secid">2.2.4.5</span>Public Input Fields Cannot Reference Internals</a></li>
<li><a href="#sec-Required-Input-Fields-cannot-be-internal"><span class="spec-secid">2.2.4.6</span>Required Input Fields cannot be internal</a></li>
</ol>
</li>
<li><a href="#sec-Enum-Types"><span class="spec-secid">2.2.5</span>Enum Types</a><ol>
<li><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs"><span class="spec-secid">2.2.5.1</span>Values Must Be The Same Across Subgraphs</a></li>
<li><a href="#sec-Default-Value-Uses-Internals"><span class="spec-secid">2.2.5.2</span>Default Value Uses Internals</a></li>
<li><a href="#sec-Empty-Merged-Enum-Type"><span class="spec-secid">2.2.5.3</span>Empty Merged Enum Type</a></li>
</ol>
</li>
<li><a href="#sec-Interface"><span class="spec-secid">2.2.6</span>Interface</a><ol>
<li><a href="#sec-Empty-Merged-Interface-Type"><span class="spec-secid">2.2.6.1</span>Empty Merged Interface Type</a></li>
</ol>
</li>
<li><a href="#sec-Union"><span class="spec-secid">2.2.7</span>Union</a><ol>
<li><a href="#sec-Union-Type-Members-Cannot-Reference-Internals"><span class="spec-secid">2.2.7.1</span>Union Type Members Cannot Reference Internals</a></li>
</ol>
</li>
<li><a href="#sec-Schema"><span class="spec-secid">2.2.8</span>Schema</a><ol>
<li><a href="#sec-No-Queries"><span class="spec-secid">2.2.8.1</span>No Queries</a></li>
</ol>
</li>
<li><a href="#sec-Shared-Functions"><span class="spec-secid">2.2.9</span>Shared Functions</a><ol>
<li><a href="#sec-Same-Type-Shape"><span class="spec-secid">2.2.9.1</span>Same Type Shape</a></li>
<li><a href="#sec-Is-Exposed"><span class="spec-secid">2.2.9.2</span>Is Exposed</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#sec-Compose"><span class="spec-secid">2.3</span>Compose</a><ol>
<li><a href="#sec-MergeObjectType"><span class="spec-secid">2.3.1</span>MergeObjectType</a></li>
<li><a href="#sec-MergeInputType"><span class="spec-secid">2.3.2</span>MergeInputType</a></li>
<li><a href="#sec-MergeInterfaceType"><span class="spec-secid">2.3.3</span>MergeInterfaceType</a></li>
<li><a href="#sec-MergeUnionType"><span class="spec-secid">2.3.4</span>MergeUnionType</a></li>
<li><a href="#sec-MergeEnumType"><span class="spec-secid">2.3.5</span>MergeEnumType</a></li>
<li><a href="#sec-MergeInputField"><span class="spec-secid">2.3.6</span>MergeInputField</a></li>
<li><a href="#sec-MergeOutputField"><span class="spec-secid">2.3.7</span>MergeOutputField</a></li>
<li><a href="#sec-MergeArguments"><span class="spec-secid">2.3.8</span>MergeArguments</a></li>
<li><a href="#sec-MergeArgument"><span class="spec-secid">2.3.9</span>MergeArgument</a></li>
<li><a href="#sec-MergeInterfaceImplementation"><span class="spec-secid">2.3.10</span>MergeInterfaceImplementation</a></li>
<li><a href="#sec-MergeInputFieldType"><span class="spec-secid">2.3.11</span>MergeInputFieldType</a></li>
<li><a href="#sec-MergeOutputFieldType"><span class="spec-secid">2.3.12</span>MergeOutputFieldType</a></li>
<li><a href="#sec-EnsureNonNullType"><span class="spec-secid">2.3.13</span>EnsureNonNullType</a></li>
<li><a href="#sec-EnsureNullableType"><span class="spec-secid">2.3.14</span>EnsureNullableType</a></li>
<li><a href="#sec-ToListType"><span class="spec-secid">2.3.15</span>ToListType</a></li>
</ol>
</li>
<li><a href="#sec-Finalize"><span class="spec-secid">2.4</span>Finalize</a></li>
</ol>
</li>
<li><a href="#sec-Executor"><span class="spec-secid">3</span>Executor</a><ol>
<li><a href="#sec-Configuration"><span class="spec-secid">3.1</span>Configuration</a><ol>
<li><a href="#sec--variable"><span class="spec-secid">3.1.1</span>@variable</a></li>
<li><a href="#sec--resolver"><span class="spec-secid">3.1.2</span>@resolver</a></li>
<li><a href="#sec--source"><span class="spec-secid">3.1.3</span>@source</a></li>
<li><a href="#sec--owner"><span class="spec-secid">3.1.4</span>@owner</a></li>
<li><a href="#sec-Subgraphs"><span class="spec-secid">3.1.5</span>Subgraphs</a></li>
<li><a href="#sec--transport"><span class="spec-secid">3.1.6</span>@transport</a></li>
<li><a href="#sec-ResolverKind"><span class="spec-secid">3.1.7</span>ResolverKind</a></li>
<li><a href="#sec-Value"><span class="spec-secid">3.1.8</span>Value</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#sec-Shared-Types"><span class="spec-secid">4</span>Shared Types</a><ol>
<li><a href="#sec--fusion"><span class="spec-secid">4.1</span>@fusion</a></li>
<li><a href="#sec-Name"><span class="spec-secid">4.2</span>Name</a></li>
<li><a href="#sec-FieldSelection"><span class="spec-secid">4.3</span>FieldSelection</a></li>
<li><a href="#sec-Version"><span class="spec-secid">4.4</span>Version</a></li>
</ol>
</li>
<li><a href="#sec-Appendix-Definitions"><span class="spec-secid">A</span>Appendix: Definitions</a><ol>
<li><a href="#sec-Appendix-Definitions.Composite-Types"><span class="spec-secid">A.1</span>Composite Types</a></li>
</ol>
</li>
<li><a href="#index"><span class="spec-secid">§</span>Index</a></li>
</ol>
</nav>
</header>
<section id="sec-Overview" secid="1">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Overview">1</a></span>Overview</h1>
<p>The GraphQL Composite Schemas specification describes how multiple GraphQL services, known as <em>subgraphs</em>, are combined into a single unified GraphQL schema called the <em>supergraph</em>.</p>
<p>For clients querying the unified GraphQL schema, the implementation details and complexities of the distributed systems behind it are hidden. The observable behavior of the distributed GraphQL executor is the same as that of a standard GraphQL executor as described by the GraphQL specification.</p>
<p>This specification focuses on two core components to allow interoperability between tooling and gateways from different implementers, the schema composition and the execution.</p>
<ul>
<li><strong>Composition</strong>: The schema composition describes a process of merging subgraph schemas into a single GraphQL schema. This schema is annotated with execution directives and is referred to as the Gateway Configuration.</li>
<li><strong>Execution</strong>: The distributed GraphQL executor specifies the Gateway Configuration and the core execution algorithms.</li>
</ul>
<p>The GraphQL Composite Schemas spec describes a colaborative approach towards build a single graph composed from multiple <em>subgraphs</em> by specifying the algorithms to merge different GraphQL <em>subgraph</em>s chemas into a single <em>supergraph</em>.</p>
<p>Two subgraphs exposing a type with the same name form a distributed type in the <em>supergraph</em>.</p>
<pre id="example-4baef" class="spec-example" data-language="graphql"><a href="#example-4baef">Example № 3</a><code><span class="token comment"># subgraph 1</span>
<span class="token keyword">type</span> <span class="token class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">b</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># subgraph 2</span>
<span class="token keyword">type</span> <span class="token class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">c</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># supergraph</span>
<span class="token keyword">type</span> <span class="token class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">b</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">c</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<section id="sec-Overview.Entities" secid="1.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Overview.Entities">1.1</a></span>Entities</h2>
<p>Entities are objects with a stable identity that endure over time. They typically represent core domain objects that act as entry points to a graph. In a distributed architecture, each <em>subgraph</em> can contribute different fields to the same entity, and is responsible for resolving only the fields that it contributes. In such an architecture, entities effectively act as hubs that enable transparent traversal across service boundaries.</p>
</section>
<section id="sec-Keys" secid="1.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Keys">1.2</a></span>Keys</h2>
<p>A representation of an object&rsquo;s identity is known as a key. Keys consist of one or more fields from an object, and are infered from the entity resolvers. An entity can have many keys as entities can have many entity resolvers. </p>
</section>
</section>
<section id="sec-Composition" secid="2">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Composition">2</a></span>Composition</h1>
<p>The composition of subgraphs describes the process of merging multiple subgraph schemas into a single GraphQL schema that is annotated with execution directives. This single GraphQL schema is the output of the Schema Composition and represents the Gateway Configuration. The schema composition process is divided into four algorithms, <code>Validate</code>, <code>Compose</code>, and <code>Finalize</code> that are run in order.</p>
<section id="sec-Directives" secid="2.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Directives">2.1</a></span>Directives</h2>
<p>Composition directives offer instructions for the schema composition process, detailing type system member semantics and specifying type transformations. In many cases subgraph schemas can be composed without any directives.</p>
<section id="sec-Directives.Entities" secid="2.1.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Directives.Entities">2.1.1</a></span>Entities</h3>
<section id="sec--entityResolver" secid="2.1.1.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--entityResolver">2.1.1.1</a></span>@entityResolver</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@entityResolver</span> <span class="token keyword">on</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<pre id="example-d6c3c" class="spec-example" data-language="graphql"><a href="#example-d6c3c">Example № 4</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
  <span class="token attr-name">personById</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span> <span class="token directive function">@entityResolver</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-b0676" class="spec-example" data-language="graphql"><a href="#example-b0676">Example № 5</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">node</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Node</span> <span class="token directive function">@entityResolver</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-c6520" class="spec-example" data-language="graphql"><a href="#example-c6520">Example № 6</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">_entities</span><span class="token punctuation">(</span><span class="token attr-name">representation</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Any</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Node</span> <span class="token directive function">@entityResolver</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec--is" secid="2.1.1.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--is">2.1.1.2</a></span>@is</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@is</span><span class="token punctuation">(</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token class-name">FieldSelection</span>
  <span class="token attr-name">coordinate</span><span class="token punctuation">:</span> <span class="token class-name">SchemaCoordinate</span>
<span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">FIELD_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">ARGUMENT_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">INPUT_FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@is</code> directive is utilized to establish semantic equivalence between disparate type system members across distinct subgraphs, which the schema composition uses to connect types.</p>
<p>In the following example, the directive specifies that the <code>id</code> argument on the field <code>Query.personById</code> and the field <code>Person.id</code> on the return type of the field are semantically the same. This information is used to infer an entity resolver for <code>Person</code> from the field <code>Query.personById</code>.</p>
<pre id="example-b2a8a" class="spec-example" data-language="graphql"><a href="#example-b2a8a">Example № 7</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token property-query">personById</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span> <span class="token directive function">@entityResolver</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>@is</code> directive also allows to refer to nested fields relative to <code>Person</code>.</p>
<pre id="example-824fb" class="spec-example" data-language="graphql"><a href="#example-824fb">Example № 8</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token property-query">personByAddressId</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"address { id }"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>@is</code> directive not limited to a single argument.</p>
<pre id="example-63cc4" class="spec-example" data-language="graphql"><a href="#example-63cc4">Example № 9</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token property-query">personByAddressId</span><span class="token punctuation">(</span>
    <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"address { id }"</span><span class="token punctuation">)</span>
    <span class="token attr-name">kind</span><span class="token punctuation">:</span> <span class="token class-name">PersonKind</span> <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"kind"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The directive can also establish semantic equivalence between two output fields. In this example, the field <code>productSKU</code> is semantically equivalent to the field <code>Product.sku</code>, allowing the schema composition to infer the connection of the <code>Product</code> with the <code>Review</code> type.</p>
<pre id="example-62cfb" class="spec-example" data-language="graphql"><a href="#example-62cfb">Example № 10</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Review</span> <span class="token punctuation">{</span>
  <span class="token attr-name">productSKU</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">coordinate</span><span class="token punctuation">:</span> <span class="token string">"Product.sku"</span><span class="token punctuation">)</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">product</span><span class="token punctuation">:</span> <span class="token class-name">Product</span> <span class="token directive function">@resolve</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>@is</code> directive can use either the <code>field</code> or <code>coordinate</code> argument. If both are specified, the schema composition must fail.</p>
<pre id="example-53747" class="spec-counter-example" data-language="graphql"><a href="#example-53747">Counter Example № 11</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Review</span> <span class="token punctuation">{</span>
  <span class="token attr-name">productSKU</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
    <span class="token directive function">@is</span><span class="token punctuation">(</span><span class="token attr-name">coordinate</span><span class="token punctuation">:</span> <span class="token string">"Product.sku"</span><span class="token punctuation">,</span> <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"product { sku }"</span><span class="token punctuation">)</span>
    <span class="token directive function">@internal</span>
  <span class="token attr-name">product</span><span class="token punctuation">:</span> <span class="token class-name">Product</span> <span class="token directive function">@resolve</span>
<span class="token punctuation">}</span>
</code></pre>
<section id="sec--is.Arguments-" class="subsec">
<h6><a href="#sec--is.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>field</code>: Represents a GraphQL field selection syntax that refers to field relative to the current type; or, when used on arguments it refers to a field relative to the return type.</li>
<li><code>coordinate</code>: Represents a schema coordinate that refers to a type system member.</li>
</ul>
</section>
</section>
</section>
<section id="sec-Shared-Data" secid="2.1.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Shared-Data">2.1.2</a></span>Shared Data</h3>
<section id="sec--shareable" secid="2.1.2.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--shareable">2.1.2.1</a></span>@shareable</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@shareable</span> <span class="token keyword">repeatable</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>By default, only one subgraph is allowed to contribute a particular field to an object type. This prevents subgraphs from inadvertently defining similarly named fields that are semantically not the same.</p>
<p>Fields have to be explicitly marked as <code>@shareable</code> to allow multiple subgraphs to define it. And it ensures the step of allowing a field to be served from multiple subgraphs is an explicit, coordinated decision.</p>
<p>If multiple subgraphs define the same field, these are assumed to be semantically equivalent, and the executor is free to choose between them as it sees fit.</p>
<div id="note-1634f" class="spec-note">
<a href="#note-1634f">Note</a>
Key fields are always considered sharable.</div>
</section>
<section id="sec--require" secid="2.1.2.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--require">2.1.2.2</a></span>@require</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@require</span><span class="token punctuation">(</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token class-name">FieldSelection</span><span class="token operator">!</span>
<span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">ARGUMENT_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">INPUT_FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@require</code> directive is used to express data requirements with other subgraphs. Arguments annotated with the <code>@require</code> directive are removed from the public exposed schema and the value for these will be resolved by the executor.</p>
<pre id="example-cc4ea" class="spec-example" data-language="graphql"><a href="#example-cc4ea">Example № 12</a><code><span class="token keyword">type</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
  <span class="token property-query">delivery</span><span class="token punctuation">(</span>
    <span class="token attr-name">zip</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
    <span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span> <span class="token directive function">@require</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"dimension { size }"</span><span class="token punctuation">)</span>
    <span class="token attr-name">weight</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span> <span class="token directive function">@require</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"dimension { weight }"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">DeliveryEstimates</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This can also be done by using input types. All fields of the input type that match the required output type are required. If the input type is only used to express a requirement it is removed from the public schema.</p>
<pre id="example-b9b86" class="spec-example" data-language="graphql"><a href="#example-b9b86">Example № 13</a><code><span class="token keyword">type</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
  <span class="token property-query">delivery</span><span class="token punctuation">(</span>
    <span class="token attr-name">zip</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
    <span class="token attr-name">dimension</span><span class="token punctuation">:</span> <span class="token atom-input class-name">ProductDimensionInput</span><span class="token operator">!</span> <span class="token directive function">@require</span><span class="token punctuation">(</span><span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token string">"dimension"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">DeliveryEstimates</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec--provides" secid="2.1.2.3">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--provides">2.1.2.3</a></span>@provides</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@provides</span><span class="token punctuation">(</span><span class="token attr-name">fields</span><span class="token punctuation">:</span> <span class="token class-name">SelectionSet</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@providse</code> directive is an optimization hint specifying child fields that can be resolved locally at the given subgraph through a particular query path. This allows for a variation of overlapping field to improve data fetching.</p>
</section>
<section id="sec--external" secid="2.1.2.4">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--external">2.1.2.4</a></span>@external</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@external</span> <span class="token keyword">on</span> <span class="token constant">OBJECT_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">INTERFACE_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@external</code> directive is used in combination with the <code>@provides</code> directive and specifies data that is not owned ba a particular subgraph.</p>
</section>
<section id="sec--override" secid="2.1.2.5">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--override">2.1.2.5</a></span>@override</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@override</span><span class="token punctuation">(</span><span class="token attr-name">from</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@override</code> directive allows to migrate fields from one subgraph to another.</p>
</section>
</section>
<section id="sec-Reshaping" secid="2.1.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Reshaping">2.1.3</a></span>Reshaping</h3>
<section id="sec--internal" secid="2.1.3.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec--internal">2.1.3.1</a></span>@internal</h4>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@internal</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span> <span class="token operator">|</span> <span class="token constant">INTERFACE</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">UNION</span> <span class="token operator">|</span> <span class="token constant">ENUM</span> <span class="token operator">|</span> <span class="token constant">ENUM_VALUE</span> <span class="token operator">|</span> <span class="token constant">INPUT_OBJECT</span> <span class="token operator">|</span> <span class="token constant">INPUT_FIELD_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">SCALAR</span>
</code></pre>
<p>The <code>@internal</code> directive signals to the composition process that annotated type system members shall not be included into the public schema but still can be used by the executor to build resolvers.</p>
</section>
</section>
<section id="sec-SchemaCoordinate" secid="2.1.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-SchemaCoordinate">2.1.4</a></span>SchemaCoordinate</h3>
<pre data-language="graphql"><code><span class="token keyword">scalar</span> <span class="token class-name">SchemaCoordinate</span>
</code></pre>
<p>The <code>SchemaCoordinate</code> scalar represents a schema coordinate syntax.</p>
<pre id="example-8b163" class="spec-example" data-language="graphql"><a href="#example-8b163">Example № 14</a><code><span class="token property">Product</span>.<span class="token property">id</span>
</code></pre>
<pre id="example-93aa2" class="spec-example" data-language="graphql"><a href="#example-93aa2">Example № 15</a><code><span class="token property">Product</span>.<span class="token property-query">estimateDelivery</span><span class="token punctuation">(</span><span class="token attr-name">zip</span><span class="token punctuation">:</span><span class="token punctuation">)</span>
</code></pre>
</section>
</section>
<section id="sec-Validate" secid="2.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Validate">2.2</a></span>Validate</h2>
<p>A GraphQL Composite Schemas spec composition tool ensures that the provided subgraph schemas are unambiguous and mistake-free in the context of the composed supergraph. The aim here is to guarantee that a composed supergraph will have no query errors due to an inconsistent schemas.</p>
<p>A request against an inconsistent supergraph is still technically executable, and will always produce a stable result as defined by the algorithms in the Execution section, however that result may be ambiguous, surprising, or unexpected relative to a request containing validation errors, so a composition tool must ensure that subgraphs involved in the supergraph allow for consistent query planning during execution.</p>
<p>Typically validation is performed in the context of the composition.</p>
<section id="sec-Types" secid="2.2.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Types">2.2.1</a></span>Types</h3>
<section id="sec-Semantical-Equvalence" secid="2.2.1.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Semantical-Equvalence">2.2.1.1</a></span>Semantical Equvalence</h4>
<section id="sec-Semantical-Equvalence.Error-Code" class="subsec">
<h6><a href="#sec-Semantical-Equvalence.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0001</p>
</section>
<section id="sec-Semantical-Equvalence.Formal-Specification" class="subsec">
<h6><a href="#sec-Semantical-Equvalence.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="typesByName">typesByName</var> be the set of all types accross all subgraphs involved in the schema composition by their given type name.</li>
<li>Given each pair of types <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> in <var data-name="typesByName">typesByName</var><ul>
<li><var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> must have the same kind</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Semantical-Equvalence.Explanatory-Text" class="subsec">
<h6><a href="#sec-Semantical-Equvalence.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>GraphQL Composite Schemas spec considers types with the same name accross subgraphs as semantically equivalent and mergable.</p>
<p>Types that do not have the same kind are considered not mergeable.</p>
<pre id="example-b5bc5" class="spec-example" data-language="graphql"><a href="#example-b5bc5">Example № 16</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">displayName</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">reviews</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Review</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-5faf6" class="spec-example" data-language="graphql"><a href="#example-5faf6">Example № 17</a><code><span class="token keyword">scalar</span> <span class="token class-name">DateTime</span>

<span class="token keyword">scalar</span> <span class="token class-name">DateTime</span>
</code></pre>
<pre id="example-81678" class="spec-counter-example" data-language="graphql"><a href="#example-81678">Counter Example № 18</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">displayName</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">scalar</span> <span class="token class-name">User</span>
</code></pre>
<pre id="example-d22ed" class="spec-counter-example" data-language="graphql"><a href="#example-d22ed">Counter Example № 19</a><code><span class="token keyword">enum</span> <span class="token class-name">UserKind</span> <span class="token punctuation">{</span>
  <span class="token constant">A</span>
  <span class="token constant">B</span>
  <span class="token constant">C</span>
<span class="token punctuation">}</span>

<span class="token keyword">scalar</span> <span class="token class-name">UserKind</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Validate.Composite-Types" secid="2.2.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Validate.Composite-Types">2.2.2</a></span>Composite Types</h3>
<section id="sec-Field-Types-Mergable" secid="2.2.2.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Types-Mergable">2.2.2.1</a></span>Field Types Mergable</h4>
<section id="sec-Field-Types-Mergable.Error-Code" class="subsec">
<h6><a href="#sec-Field-Types-Mergable.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0002</p>
</section>
<section id="sec-Field-Types-Mergable.Formal-Specification" class="subsec">
<h6><a href="#sec-Field-Types-Mergable.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="fieldsByName">fieldsByName</var> be a map of field lists where the key is the name of a field and the value is a list of fields from mergable types from different subgraphs with the same name.</li>
<li>for each <var data-name="fields">fields</var> in <var data-name="fieldsByName">fieldsByName</var><ul>
<li><span class="spec-call"><a href="#FieldsAreMergable()" data-name="FieldsAreMergable">FieldsAreMergable</a>(<var data-name="fields">fields</var>)</span> must be true.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="FieldsAreMergable()">
<span class="spec-call"><a href="#FieldsAreMergable()" data-name="FieldsAreMergable">FieldsAreMergable</a>(<var data-name="fields">fields</var>)</span><ol>
<li>Given each pair of members <var data-name="fieldA">fieldA</var> and <var data-name="fieldB">fieldB</var> in <var data-name="fields">fields</var>:<ol>
<li>Let <var data-name="typeA">typeA</var> be the type of <var data-name="fieldA">fieldA</var></li>
<li>Let <var data-name="typeB">typeB</var> be the type of <var data-name="fieldB">fieldB</var></li>
<li><span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span> must be true.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="SameTypeShape()">
<span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> is Non-Null:<ol>
<li>If <var data-name="typeB">typeB</var> is nullable<ol>
<li>Let <var data-name="innerType">innerType</var> be the inner type of <var data-name="typeA">typeA</var></li>
<li>return SameTypeShape(<var data-name="innerType">innerType</var>, <var data-name="typeB">typeB</var>)</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="typeB">typeB</var> is Non-Null:<ol>
<li>If <var data-name="typeA">typeA</var> is nullable<ol>
<li>Let <var data-name="innerType">innerType</var> be the inner type of <var data-name="typeB">typeB</var></li>
<li>return <span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="innerType">innerType</var>)</span></li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> is List:<ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> is not List, return false.</li>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the item type of <var data-name="typeA">typeA</var>.</li>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the item type of <var data-name="typeB">typeB</var>.</li>
<li>return <span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span></li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are not of the same kind<ol>
<li>return false</li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> do not have the same name<ol>
<li>return false</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Field-Types-Mergable.Explanatory-Text" class="subsec">
<h6><a href="#sec-Field-Types-Mergable.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>Fields on mergable objects or interfaces with that have the same name are considered semantically equivalent and mergable when they have a mergable field type.</p>
<p>Fields with the same type are mergable.</p>
<pre id="example-65bd6" class="spec-example" data-language="graphql"><a href="#example-65bd6">Example № 20</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Fields with different nullability are mergable, resulting in merged field with a nullable type.</p>
<pre id="example-6c133" class="spec-example" data-language="graphql"><a href="#example-6c133">Example № 21</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-a9f42" class="spec-example" data-language="graphql"><a href="#example-a9f42">Example № 22</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Fields are not mergable if the named types are different in kind or name.</p>
<pre id="example-1b751" class="spec-counter-example" data-language="graphql"><a href="#example-1b751">Counter Example № 23</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">birthdate</span><span class="token punctuation">:</span> <span class="token class-name">DateTime</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-70adb" class="spec-counter-example" data-language="graphql"><a href="#example-70adb">Counter Example № 24</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Tag</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Tag</span> <span class="token punctuation">{</span>
  <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Tag</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">scalar</span> <span class="token class-name">Tag</span>
</code></pre>
</section>
</section>
<section id="sec-Argument-Types-Mergable" secid="2.2.2.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Types-Mergable">2.2.2.2</a></span>Argument Types Mergable</h4>
<section id="sec-Argument-Types-Mergable.Error-Code" class="subsec">
<h6><a href="#sec-Argument-Types-Mergable.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0004</p>
</section>
<section id="sec-Argument-Types-Mergable.Formal-Specification" class="subsec">
<h6><a href="#sec-Argument-Types-Mergable.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="fieldsByName">fieldsByName</var> be a map of field lists where the key is the name of a field and the value is a list of fields from mergable types from different subgraphs with the same name.</li>
<li>for each <var data-name="fields">fields</var> in <var data-name="fieldsByName">fieldsByName</var><ul>
<li>if <span class="spec-call"><span data-name="FieldsInSetCanMerge">FieldsInSetCanMerge</span>(<var data-name="fields">fields</var>)</span> must be true.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="FieldsAreMergable()">
<span class="spec-call"><a href="#FieldsAreMergable()" data-name="FieldsAreMergable">FieldsAreMergable</a>(<var data-name="fields">fields</var>)</span><ol>
<li>Given each pair of members <var data-name="fieldA">fieldA</var> and <var data-name="fieldB">fieldB</var> in <var data-name="fields">fields</var>:<ol>
<li><span class="spec-call"><a href="#ArgumentsAreMergable()" data-name="ArgumentsAreMergable">ArgumentsAreMergable</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span> must be true.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="ArgumentsAreMergable()">
<span class="spec-call"><a href="#ArgumentsAreMergable()" data-name="ArgumentsAreMergable">ArgumentsAreMergable</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span><ol>
<li>Given each pair of arguments <var data-name="argumentA">argumentA</var> and <var data-name="argumentB">argumentB</var> in <var data-name="fieldA">fieldA</var> and <var data-name="fieldB">fieldB</var>:<ol>
<li>Let <var data-name="typeA">typeA</var> be the type of <var data-name="argumentA">argumentA</var></li>
<li>Let <var data-name="typeB">typeB</var> be the type of <var data-name="argumentB">argumentB</var></li>
<li><span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span> must be true.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Argument-Types-Mergable.Explanatory-Text" class="subsec">
<h6><a href="#sec-Argument-Types-Mergable.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>Fields on mergable objects or interfaces with that have the same name are considered semantically equivalent and mergable when they have a mergable argument types.</p>
<p>Fields when all matching arguments have a mergable type.</p>
<pre id="example-b9e7f" class="spec-example" data-language="graphql"><a href="#example-b9e7f">Example № 25</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Arguments that differ on nullability of an argument type are mergable.</p>
<pre id="example-405d9" class="spec-example" data-language="graphql"><a href="#example-405d9">Example № 26</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-0511f" class="spec-example" data-language="graphql"><a href="#example-0511f">Example № 27</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Arguments are not mergable if the named types are different in kind or name.</p>
<pre id="example-2716b" class="spec-counter-example" data-language="graphql"><a href="#example-2716b">Counter Example № 28</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token class-name">DateTime</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-b0575" class="spec-counter-example" data-language="graphql"><a href="#example-b0575">Counter Example № 29</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">argument</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">DateTime</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Arguments-Mergable" secid="2.2.2.3">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Arguments-Mergable">2.2.2.3</a></span>Arguments Mergable</h4>
<section id="sec-Arguments-Mergable.Error-Code" class="subsec">
<h6><a href="#sec-Arguments-Mergable.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>FXXXX</p>
</section>
<section id="sec-Arguments-Mergable.Formal-Specification" class="subsec">
<h6><a href="#sec-Arguments-Mergable.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
</section>
<section id="sec-Arguments-Mergable.Explanatory-Text" class="subsec">
<h6><a href="#sec-Arguments-Mergable.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<pre id="example-12b47" class="spec-example" data-language="graphql"><a href="#example-12b47">Example № 30</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-e5db3" class="spec-counter-example" data-language="graphql"><a href="#example-e5db3">Counter Example № 31</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">a</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">b</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Required-Arguments-Cannot-Be-Internal" secid="2.2.2.4">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Required-Arguments-Cannot-Be-Internal">2.2.2.4</a></span>Required Arguments Cannot Be Internal</h4>
<section id="sec-Required-Arguments-Cannot-Be-Internal.Error-Code" class="subsec">
<h6><a href="#sec-Required-Arguments-Cannot-Be-Internal.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0014</p>
</section>
<section id="sec-Required-Arguments-Cannot-Be-Internal.Formal-Specification" class="subsec">
<h6><a href="#sec-Required-Arguments-Cannot-Be-Internal.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="subgraphs">subgraphs</var> be a list of all subgraphs.</li>
<li>For each <var data-name="subgraph">subgraph</var> in <var data-name="subgraphs">subgraphs</var>:<ul>
<li>Let <var data-name="arguments">arguments</var> be the set of all arguments in <var data-name="subgraph">subgraph</var>.</li>
<li>For each <var data-name="argument">argument</var> in <var data-name="arguments">arguments</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="argument">argument</var>)</span> is false<ul>
<li>Let <var data-name="type">type</var> be the type of <var data-name="argument">argument</var></li>
<li><var data-name="type">type</var> must not be nullable</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Required-Arguments-Cannot-Be-Internal.Explanatory-Text" class="subsec">
<h6><a href="#sec-Required-Arguments-Cannot-Be-Internal.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>Required arguments of fields or directives (i.e., arguments that are non-nullable) must be exposed in the composed schema. Removing a required argument from the composed schema creates a contradiction where an argument is necessary for the operation in the composed schema but is not available for external use.</p>
<p>The following example illustrates a valid scenario where a required argument is not marked as <code>@internal</code>:</p>
<pre id="example-6758c" class="spec-example" data-language="graphql"><a href="#example-6758c">Example № 32</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter example, the <code>arg1</code> argument is essential for field <code>field1</code> in one of the subgraph and is marked as required, but it is also marked as <code>@internal</code>, violating the rule that required arguments cannot be internal:</p>
<pre id="example-8a6f1" class="spec-counter-example" data-language="graphql"><a href="#example-8a6f1">Counter Example № 33</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span> <span class="token directive function">@internal</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter example, the <code>arg1</code> argument is essential for field <code>field1</code> in one of the subgraph but does not exist in the other subgraph, violating the rule that required arguments cannot be internal:</p>
<pre id="example-caec8" class="spec-counter-example" data-language="graphql"><a href="#example-caec8">Counter Example № 34</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Item</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The same rule applied to directives. The following counter-example illustrate scenario where a directive argument is essential for a directive in one subgraph, but does not exist in the other subgraph:</p>
<pre id="example-03399" class="spec-counter-example" data-language="graphql"><a href="#example-03399">Counter Example № 35</a><code><span class="token keyword">directive</span> <span class="token directive function">@directive1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">FIELD</span>

<span class="token keyword">directive</span> <span class="token directive function">@directive1</span> <span class="token keyword">on</span> <span class="token constant">FIELD</span>
</code></pre>
</section>
</section>
<section id="sec-Public-Fields-Cannot-Reference-Internals" secid="2.2.2.5">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Public-Fields-Cannot-Reference-Internals">2.2.2.5</a></span>Public Fields Cannot Reference Internals</h4>
<section id="sec-Public-Fields-Cannot-Reference-Internals.Error-Code" class="subsec">
<h6><a href="#sec-Public-Fields-Cannot-Reference-Internals.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0016</p>
</section>
<section id="sec-Public-Fields-Cannot-Reference-Internals.Formal-Specification" class="subsec">
<h6><a href="#sec-Public-Fields-Cannot-Reference-Internals.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="subgraphs">subgraphs</var> be a list of all subgraphs.</li>
<li>For each <var data-name="subgraph">subgraph</var> in <var data-name="subgraphs">subgraphs</var>:<ul>
<li>Let <var data-name="fields">fields</var> be the set of all fields of the composite types in <var data-name="subgraph">subgraph</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is true<ul>
<li>Let <var data-name="namedType">namedType</var> be the named type that <var data-name="field">field</var> references</li>
<li><span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="namedType">namedType</var>)</span> must be true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Public-Fields-Cannot-Reference-Internals.Explanatory-Text" class="subsec">
<h6><a href="#sec-Public-Fields-Cannot-Reference-Internals.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>In a composed schema, a field within a composite type must only reference types that are exposed. This requirement guarantees that public types do not reference internal structures which are intended for internal use.</p>
<p>Here is a valid example where a public field references another public type:</p>
<pre id="example-c4797" class="spec-example" data-language="graphql"><a href="#example-c4797">Example № 36</a><code><span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Object2</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field4</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This is another valid case where the internal type is not exposed in the composed schema:</p>
<pre id="example-e72f1" class="spec-example" data-language="graphql"><a href="#example-e72f1">Example № 37</a><code><span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Object2</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field4</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>However, it becomes invalid if a public field in one subgraph references a type that is marked as <code>@internal</code> in another subgraph:</p>
<pre id="example-24fd6" class="spec-counter-example" data-language="graphql"><a href="#example-24fd6">Counter Example № 38</a><code><span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Object2</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Object2</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field5</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Object-Types" secid="2.2.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Object-Types">2.2.3</a></span>Object Types</h3>
<section id="sec-Empty-Merged-Object-Type" secid="2.2.3.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Empty-Merged-Object-Type">2.2.3.1</a></span>Empty Merged Object Type</h4>
<section id="sec-Empty-Merged-Object-Type.Error-Code" class="subsec">
<h6><a href="#sec-Empty-Merged-Object-Type.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0019</p>
</section>
<section id="sec-Empty-Merged-Object-Type.Formal-Specification" class="subsec">
<h6><a href="#sec-Empty-Merged-Object-Type.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="types">types</var> be the set of all object types across all subgraphs</li>
<li>For each <var data-name="type">type</var> in <var data-name="types">types</var>:<ul>
<li><span class="spec-call"><a href="#IsObjectTypeEmpty()" data-name="IsObjectTypeEmpty">IsObjectTypeEmpty</a>(<var data-name="type">type</var>)</span> must be false.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="IsObjectTypeEmpty()">
<span class="spec-call"><a href="#IsObjectTypeEmpty()" data-name="IsObjectTypeEmpty">IsObjectTypeEmpty</a>(<var data-name="type">type</var>)</span><ol>
<li>Let <var data-name="fields">fields</var> be a set of all fields of all types with coordinate and kind <var data-name="type">type</var> across all subgraphs</li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is true<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
</section>
<section id="sec-Empty-Merged-Object-Type.Explanatory-Text" class="subsec">
<h6><a href="#sec-Empty-Merged-Object-Type.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>For object types defined across multiple subgraphs, the merged object type is the superset of all fields defined in these subgraphs. However, any field marked with <code>@internal</code> in any subgraph is hidden and not included in the merged object type. An object type with no fields, after considering <code>@internal</code> markings, is considered empty and invalid.</p>
<p>In the following example, the merged object type <code>ObjectType1</code> is valid. It includes all fields from both subgraphs, with <code>field2</code> being hidden due to the <code>@internal</code> directive in one of the subgraphs:</p>
<pre data-language="graphql"><code><span class="token keyword">type</span> <span class="token class-name">ObjectType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ObjectType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This counter-example demonstrates an invalid merged object type. In this case, <code>ObjectType1</code> is defined in two subgraphs, but all fields are marked as <code>@internal</code> in at least one of the subgraphs, resulting in an empty merged object type:</p>
<pre id="example-a1f46" class="spec-counter-example" data-language="graphql"><a href="#example-a1f46">Counter Example № 39</a><code><span class="token keyword">type</span> <span class="token class-name">ObjectType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ObjectType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Input-Object-Types" secid="2.2.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-Types">2.2.4</a></span>Input Object Types</h3>
<section id="sec-Input-Field-Types-Mergable" secid="2.2.4.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Field-Types-Mergable">2.2.4.1</a></span>Input Field Types Mergable</h4>
<section id="sec-Input-Field-Types-Mergable.Error-Code" class="subsec">
<h6><a href="#sec-Input-Field-Types-Mergable.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0005</p>
</section>
<section id="sec-Input-Field-Types-Mergable.Formal-Specification" class="subsec">
<h6><a href="#sec-Input-Field-Types-Mergable.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="fieldsByName">fieldsByName</var> be a map of field lists where the key is the name of a field and the value is a list of fields from mergable input types from different subgraphs with the same name.</li>
<li>For each <var data-name="fields">fields</var> in <var data-name="fieldsByName">fieldsByName</var>:<ul>
<li>if <span class="spec-call"><a href="#InputFieldsAreMergable()" data-name="InputFieldsAreMergable">InputFieldsAreMergable</a>(<var data-name="fields">fields</var>)</span> must be true.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="InputFieldsAreMergable()">
<span class="spec-call"><a href="#InputFieldsAreMergable()" data-name="InputFieldsAreMergable">InputFieldsAreMergable</a>(<var data-name="fields">fields</var>)</span><ol>
<li>Given each pair of members <var data-name="fieldA">fieldA</var> and <var data-name="fieldB">fieldB</var> in <var data-name="fields">fields</var>:<ol>
<li>Let <var data-name="typeA">typeA</var> be the type of <var data-name="fieldA">fieldA</var>.</li>
<li>Let <var data-name="typeB">typeB</var> be the type of <var data-name="fieldB">fieldB</var>.</li>
<li><span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span> must be true.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Input-Field-Types-Mergable.Explanatory-Text" class="subsec">
<h6><a href="#sec-Input-Field-Types-Mergable.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>The input fields of input objects with the same name must be mergable. This rule ensures that input objects with the same name in different subgraphs have fields that can be consistently merged without conflict.</p>
<p>Input fields are considered mergable when they share the same name and have compatible types. The compatibility of types is determined by their structure (lists), excluding nullability. Mergable input fields with different nullability are considered mergable, and the resulting merged field will be the most permissive of the two.</p>
<p>In this example, the field <code>field</code> in <code>Input1</code> has compatible types across subgraphs, making them mergable:</p>
<pre id="example-e09b1" class="spec-example" data-language="graphql"><a href="#example-e09b1">Example № 40</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, the field <code>tags</code> in <code>Input1</code> is a list type with compatible inner types, satisfying the mergable criteria:</p>
<pre id="example-6c61f" class="spec-example" data-language="graphql"><a href="#example-6c61f">Example № 41</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter-example, the field <code>field</code> in <code>Input1</code> has incompatible types (<code>String</code> and <code>DateTime</code>), making them not mergable:</p>
<pre id="example-ea830" class="spec-counter-example" data-language="graphql"><a href="#example-ea830">Counter Example № 42</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token class-name">DateTime</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, the field <code>tags</code> in <code>Input1</code> is a list type with incompatible inner types (<code>String</code> and <code>DateTime</code>), violating the mergable rule:</p>
<pre id="example-03798" class="spec-counter-example" data-language="graphql"><a href="#example-03798">Counter Example № 43</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">DateTime</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Input-With-Different-Fields" secid="2.2.4.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-With-Different-Fields">2.2.4.2</a></span>Input With Different Fields</h4>
<section id="sec-Input-With-Different-Fields.Error-Code" class="subsec">
<h6><a href="#sec-Input-With-Different-Fields.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0006</p>
</section>
<section id="sec-Input-With-Different-Fields.Formal-Specification" class="subsec">
<h6><a href="#sec-Input-With-Different-Fields.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="inputsByName">inputsByName</var> be a map where the key is the name of an input object type, and the value is a list of all input object types from different subgraphs with that name.</li>
<li>For each <var data-name="listOfInputs">listOfInputs</var> in <var data-name="inputsByName">inputsByName</var>:<ul>
<li><span class="spec-call"><a href="#InputFieldsAreMergable()" data-name="InputFieldsAreMergable">InputFieldsAreMergable</a>(<var data-name="listOfInputs">listOfInputs</var>)</span> must be true.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="InputFieldsAreMergable()">
<span class="spec-call"><a href="#InputFieldsAreMergable()" data-name="InputFieldsAreMergable">InputFieldsAreMergable</a>(<var data-name="inputs">inputs</var>)</span><ol>
<li>Let <var data-name="fields">fields</var> be the set of all field names of the first input object in <var data-name="inputs">inputs</var>.</li>
<li>For each <var data-name="input">input</var> in <var data-name="inputs">inputs</var>:<ol>
<li>Let <var data-name="inputFields">inputFields</var> be the set of all field names of <var data-name="input">input</var>.</li>
<li><var data-name="fields">fields</var> must be equal to <var data-name="inputFields">inputFields</var>.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Input-With-Different-Fields.Explanatory-Text" class="subsec">
<h6><a href="#sec-Input-With-Different-Fields.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>This rule ensures that input object types with the same name across different subgraphs have identical sets of field names. Consistency in input object fields across subgraphs is required to avoid conflicts and ambiguities in the composed schema. This rule only checks that the field names are the same, not that the field types are the same. Field types are checked by the <a href="#sec-Input-Field-Types-Mergable">Input Field Types Mergable</a> rule.</p>
<p>When an input object is defined with differing fields across subgraphs, it can lead to issues in query execution. A field expected in one subgraph might be absent in another, leading to undefined behavior. This rule prevents such inconsistencies by enforcing that all instances of the same named input object across subgraphs have a matching set of field names.</p>
<p>In this example, both subgraphs define <code>Input1</code> with the same field <code>field1</code>, satisfying the rule:</p>
<pre id="example-2f0a2" class="spec-example" data-language="graphql"><a href="#example-2f0a2">Example № 44</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, the two definitions of <code>Input1</code> have different fields (<code>field1</code> and <code>field2</code>), violating the rule:</p>
<pre id="example-26084" class="spec-counter-example" data-language="graphql"><a href="#example-26084">Counter Example № 45</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Empty-Merged-Input-Object-Type" secid="2.2.4.3">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Empty-Merged-Input-Object-Type">2.2.4.3</a></span>Empty Merged Input Object Type</h4>
<section id="sec-Empty-Merged-Input-Object-Type.Error-Code" class="subsec">
<h6><a href="#sec-Empty-Merged-Input-Object-Type.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0010</p>
</section>
<section id="sec-Empty-Merged-Input-Object-Type.Formal-Specification" class="subsec">
<h6><a href="#sec-Empty-Merged-Input-Object-Type.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="inputs">inputs</var> be the set of all input object types across all subgraphs</li>
<li>For each <var data-name="input">input</var> in <var data-name="inputs">inputs</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="input">input</var>)</span> is true<ul>
<li><span class="spec-call"><a href="#IsInputObjectTypeEmpty()" data-name="IsInputObjectTypeEmpty">IsInputObjectTypeEmpty</a>(<var data-name="input">input</var>)</span> must be false</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="IsInputObjectTypeEmpty()">
<span class="spec-call"><a href="#IsInputObjectTypeEmpty()" data-name="IsInputObjectTypeEmpty">IsInputObjectTypeEmpty</a>(<var data-name="input">input</var>)</span><ol>
<li>Let <var data-name="fields">fields</var> be a set of all input fields across all subraphs with coordinate <var data-name="input">input</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is true<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Empty-Merged-Input-Object-Type.Explanatory-Text" class="subsec">
<h6><a href="#sec-Empty-Merged-Input-Object-Type.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>When an input object type is defined in multiple subgraphs, only common fields and fields not flagged as <code>@internal</code> are included in the merged input object type. If this process results in an input object type with no fields, the input object type is considered empty and invalid.</p>
<p>In the following example, the merged input object type <code>Input1</code> is valid. The type is defined in two subgraphs:</p>
<pre data-language="graphql"><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged input object type <code>Input1</code> is valid and contains <code>field1</code> as it exists in both subgraphs. The type is defined in two subgraphs:</p>
<pre data-language="graphql"><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged input object type <code>Input1</code> is invalid. The type is defined in two subgraphs, but do not have any common fields.</p>
<pre id="example-eb2e4" class="spec-counter-example" data-language="graphql"><a href="#example-eb2e4">Counter Example № 46</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This counter-example shows an invalid merged input object type. The <code>Input1</code> type is defined in two subgraphs, but both <code>field1</code> and <code>field2</code> are flagged as <code>@internal</code> in one of the subgraphs:</p>
<pre id="example-9b9e7" class="spec-counter-example" data-language="graphql"><a href="#example-9b9e7">Counter Example № 47</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter-example, the <code>Input1</code> type is defined in two subgraphs, but <code>field1</code> is flagged as <code>@internal</code> in one subgraph and <code>field2</code> is flagged as <code>@internal</code> in the other subgraph, resulting in an empty merged input object type:</p>
<pre id="example-86e3d" class="spec-counter-example" data-language="graphql"><a href="#example-86e3d">Counter Example № 48</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged input object type <code>Input1</code> is invalid. The type is defined in two subgraphs, but do not have the common field <code>field1</code> is flagged as <code>@internal</code> in one of the subgraphs:</p>
<pre id="example-04747" class="spec-counter-example" data-language="graphql"><a href="#example-04747">Counter Example № 49</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Input-Field-Default-Mismatch" secid="2.2.4.4">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Field-Default-Mismatch">2.2.4.4</a></span>Input Field Default Mismatch</h4>
<section id="sec-Input-Field-Default-Mismatch.Error-Code" class="subsec">
<h6><a href="#sec-Input-Field-Default-Mismatch.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0011</p>
</section>
<section id="sec-Input-Field-Default-Mismatch.Formal-Specification" class="subsec">
<h6><a href="#sec-Input-Field-Default-Mismatch.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="inputFieldsByName">inputFieldsByName</var> be a map where the key is the name of an input field and the value is a list of input fields from different subgraphs from the same type with the same name.</li>
<li>For each <var data-name="inputFields">inputFields</var> in <var data-name="inputFieldsByName">inputFieldsByName</var>:<ul>
<li>Let <var data-name="defaultValues">defaultValues</var> be a set containing the default values of each input field in <var data-name="inputFields">inputFields</var>.</li>
<li>If the size of <var data-name="defaultValues">defaultValues</var> is greater than<ul>
<li><span class="spec-call"><a href="#InputFieldsHaveConsistentDefaults()" data-name="InputFieldsHaveConsistentDefaults">InputFieldsHaveConsistentDefaults</a>(<var data-name="inputFields">inputFields</var>)</span> must be false.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="InputFieldsHaveConsistentDefaults()">
<span class="spec-call"><a href="#InputFieldsHaveConsistentDefaults()" data-name="InputFieldsHaveConsistentDefaults">InputFieldsHaveConsistentDefaults</a>(<var data-name="inputFields">inputFields</var>)</span><ol>
<li>Given each pair of input fields <var data-name="inputFieldA">inputFieldA</var> and <var data-name="inputFieldB">inputFieldB</var> in <var data-name="inputFields">inputFields</var>:<ol>
<li>If the default value of <var data-name="inputFieldA">inputFieldA</var> is not equal to the default value of <var data-name="inputFieldB">inputFieldB</var>:<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
</section>
<section id="sec-Input-Field-Default-Mismatch.Explanatory-Text" class="subsec">
<h6><a href="#sec-Input-Field-Default-Mismatch.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>Input fields in different subgraphs that have the same name are required to have consistent default values. This ensures that there is no ambiguity or inconsistency when merging schemas from different subgraphs.</p>
<p>A mismatch in default values for input fields with the same name across different subgraphs will result in a schema composition error.</p>
<p>In the the following example both subgraphs have an input field <code>field1</code> with the same default value. This is valid:</p>
<pre id="example-b6ec8" class="spec-example" data-language="graphql"><a href="#example-b6ec8">Example № 50</a><code><span class="token keyword">input</span> <span class="token object">Filter</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">Enum1</span> <span class="token operator">=</span> <span class="token property">Value1</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Filter</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">Enum1</span> <span class="token operator">=</span> <span class="token property">Value1</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example both subgraphs define an input field <code>field1</code> with different default values. This is invalid:</p>
<pre id="example-69ecb" class="spec-counter-example" data-language="graphql"><a href="#example-69ecb">Counter Example № 51</a><code><span class="token keyword">input</span> <span class="token object">Filter</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Filter</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token operator">=</span> <span class="token number">20</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Public-Input-Fields-Cannot-Reference-Internals" secid="2.2.4.5">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals">2.2.4.5</a></span>Public Input Fields Cannot Reference Internals</h4>
<section id="sec-Public-Input-Fields-Cannot-Reference-Internals.Error-Code" class="subsec">
<h6><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0015</p>
</section>
<section id="sec-Public-Input-Fields-Cannot-Reference-Internals.Formal-Specification" class="subsec">
<h6><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="subgraphs">subgraphs</var> be a list of all subgraphs.</li>
<li>For each <var data-name="subgraph">subgraph</var> in <var data-name="subgraphs">subgraphs</var>:<ul>
<li>Let <var data-name="fields">fields</var> be the set of all fields of the input types in <var data-name="subgraph">subgraph</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is true<ul>
<li>Let <var data-name="namedType">namedType</var> be the named type that <var data-name="field">field</var> references</li>
<li><span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="namedType">namedType</var>)</span> must be true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Public-Input-Fields-Cannot-Reference-Internals.Explanatory-Text" class="subsec">
<h6><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>In a composed schema, a field within a input type must only reference types that are exposed. This requirement guarantees that public types do not reference internal structures which are intended for internal use.</p>
<p>A valid case where a public input field references another public input type:</p>
<pre id="example-36c2c" class="spec-example" data-language="graphql"><a href="#example-36c2c">Example № 52</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Input2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Input2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Another valid case is where the field is not exposed in the composed schema:</p>
<pre id="example-92c0a" class="spec-example" data-language="graphql"><a href="#example-92c0a">Example № 53</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Input2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field4</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>An invalid case where a public input field in one subgraph references an input type that is marked as <code>@internal</code> in another subgraph:</p>
<pre id="example-9a0df" class="spec-counter-example" data-language="graphql"><a href="#example-9a0df">Counter Example № 54</a><code><span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token class-name">Input2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field4</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token property">Input2</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Required-Input-Fields-cannot-be-internal" secid="2.2.4.6">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Required-Input-Fields-cannot-be-internal">2.2.4.6</a></span>Required Input Fields cannot be internal</h4>
<section id="sec-Required-Input-Fields-cannot-be-internal.Error-Code" class="subsec">
<h6><a href="#sec-Required-Input-Fields-cannot-be-internal.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0012</p>
</section>
<section id="sec-Required-Input-Fields-cannot-be-internal.Formal-Specification" class="subsec">
<h6><a href="#sec-Required-Input-Fields-cannot-be-internal.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="subgraphs">subgraphs</var> be a list of all subgraphs.</li>
<li>For each <var data-name="subgraph">subgraph</var> in <var data-name="subgraphs">subgraphs</var>:<ul>
<li>Let <var data-name="inputs">inputs</var> be the set of all input object types in the <var data-name="subgraph">subgraph</var></li>
<li>For each <var data-name="input">input</var> in <var data-name="inputs">inputs</var>:<ul>
<li>Let <var data-name="fields">fields</var> be a list of fields of <var data-name="input">input</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is false<ul>
<li>Let <var data-name="type">type</var> be the type of <var data-name="field">field</var></li>
<li><var data-name="type">type</var> must not be nullable</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Required-Input-Fields-cannot-be-internal.Explanatory-Text" class="subsec">
<h6><a href="#sec-Required-Input-Fields-cannot-be-internal.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>Input object types can be defined in multiple subgraphs. Required fields in these input object types (i.e., fields that are non-nullable) must be exposed in the composed graph. A required internal field would create a contradiction where a field is both necessary for the operation in the composed schema but also not available for external use.</p>
<p>This example shows a valid scenario where the required field is not marked as <code>@internal</code>:</p>
<pre id="example-84159" class="spec-example" data-language="graphql"><a href="#example-84159">Example № 55</a><code><span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Consider the following example where an input object type <code>InputType1</code> includes a required field <code>field1</code>:</p>
<pre id="example-3c983" class="spec-counter-example" data-language="graphql"><a href="#example-3c983">Counter Example № 56</a><code><span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter-example, the field <code>field1</code> is only defined in one subgraph, so will not be included in the composed schema. Therefor this field cannot be non-nullable:</p>
<pre id="example-a30bf" class="spec-counter-example" data-language="graphql"><a href="#example-a30bf">Counter Example № 57</a><code><span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">InputType1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Enum-Types" secid="2.2.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Enum-Types">2.2.5</a></span>Enum Types</h3>
<section id="sec-Values-Must-Be-The-Same-Across-Subgraphs" secid="2.2.5.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs">2.2.5.1</a></span>Values Must Be The Same Across Subgraphs</h4>
<section id="sec-Values-Must-Be-The-Same-Across-Subgraphs.Error-Code" class="subsec">
<h6><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0003</p>
</section>
<section id="sec-Values-Must-Be-The-Same-Across-Subgraphs.Formal-Specification" class="subsec">
<h6><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="enumsByName">enumsByName</var> be a map where the key is the name of an enum type, and the value is a list of all enum types from different subgraphs with that name.</li>
<li>For each <var data-name="listOfEnum">listOfEnum</var> in <var data-name="enumsByName">enumsByName</var>:<ul>
<li><span class="spec-call"><a href="#EnumAreMergable()" data-name="EnumAreMergable">EnumAreMergable</a>(<var data-name="listOfEnum">listOfEnum</var>)</span> must be true.</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="EnumAreMergable()">
<span class="spec-call"><a href="#EnumAreMergable()" data-name="EnumAreMergable">EnumAreMergable</a>(<var data-name="enums">enums</var>)</span><ol>
<li>Let <var data-name="values">values</var> be the set of all values of the first enum in <var data-name="enums">enums</var></li>
<li>For each <var data-name="enum">enum</var> in <var data-name="enums">enums</var><ol>
<li>Let <var data-name="enumValues">enumValues</var> be the set of all values of <var data-name="enum">enum</var></li>
<li><var data-name="values">values</var> must be equal to <var data-name="enumValues">enumValues</var></li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Values-Must-Be-The-Same-Across-Subgraphs.Explanatory-Text" class="subsec">
<h6><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>This rule ensures that enum types with the same name across different subgraphs in a supergraph have identical sets of values. Enums, must be consistent across subgraphs to avoid conflicts and ambiguities in the composed schema.</p>
<p>When an enum is defined with differing values across subgraphs, it can lead to confusion and errors in query execution. For instance, a value valid in one subgraph might be passed to another where it&rsquo;s unrecognized, leading to unexpected behavior or failures. This rule prevents such inconsistencies by enforcing that all instances of the same named enum across subgraphs have an exact match in their values.</p>
<p>In this example, both subgraphs define <code>Enum1</code> with the same value <code>BAR</code>, satisfying the rule:</p>
<pre id="example-8ff64" class="spec-example" data-language="graphql"><a href="#example-8ff64">Example № 58</a><code><span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token constant">BAR</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token constant">BAR</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, the two definitions of <code>Enum1</code> have different values (<code>BAR</code> and <code>Baz</code>), violating the rule:</p>
<pre id="example-33373" class="spec-counter-example" data-language="graphql"><a href="#example-33373">Counter Example № 59</a><code><span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token constant">BAR</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Baz</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-Default-Value-Uses-Internals" secid="2.2.5.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Default-Value-Uses-Internals">2.2.5.2</a></span>Default Value Uses Internals</h4>
<section id="sec-Default-Value-Uses-Internals.Error-Code" class="subsec">
<h6><a href="#sec-Default-Value-Uses-Internals.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0008</p>
</section>
<section id="sec-Default-Value-Uses-Internals.Formal-Specification" class="subsec">
<h6><a href="#sec-Default-Value-Uses-Internals.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li><span class="spec-call"><a href="#ValidateArgumentDefaultValues()" data-name="ValidateArgumentDefaultValues">ValidateArgumentDefaultValues</a>()</span> must be true.</li>
<li><span class="spec-call"><a href="#ValidateInputFieldDefaultValues()" data-name="ValidateInputFieldDefaultValues">ValidateInputFieldDefaultValues</a>()</span> must be true.</li>
</ul>
<div class="spec-algo" id="ValidateArgumentDefaultValues()">
<span class="spec-call"><a href="#ValidateArgumentDefaultValues()" data-name="ValidateArgumentDefaultValues">ValidateArgumentDefaultValues</a>()</span><ol>
<li>Let <var data-name="arguments">arguments</var> be all arguments of fields and directives across all subgraphs</li>
<li>For each <var data-name="argument">argument</var> in <var data-name="arguments">arguments</var><ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="argument">argument</var>)</span> is true and has a default value:<ol>
<li>Let <var data-name="defaultValue">defaultValue</var> be the default value of <var data-name="argument">argument</var></li>
<li>If not ValidateDefaultValue(defaultValue)<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
<div class="spec-algo" id="ValidateInputFieldDefaultValues()">
<span class="spec-call"><a href="#ValidateInputFieldDefaultValues()" data-name="ValidateInputFieldDefaultValues">ValidateInputFieldDefaultValues</a>()</span><ol>
<li>Let <var data-name="inputFields">inputFields</var> be all input fields of across all subgraphs</li>
<li>For each <var data-name="inputField">inputField</var> in <var data-name="inputFields">inputFields</var>:<ol>
<li>Let <var data-name="type">type</var> be the type of <var data-name="inputField">inputField</var></li>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="inputField">inputField</var>)</span> is true and <var data-name="inputField">inputField</var> has a default value:<ol>
<li>Let <var data-name="defaultValue">defaultValue</var> be the default value of <var data-name="inputField">inputField</var></li>
<li>if ValidateDefaultValue(defaultValue) is false<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
<div class="spec-algo" id="ValidateDefaultValue()">
<span class="spec-call"><a href="#ValidateDefaultValue()" data-name="ValidateDefaultValue">ValidateDefaultValue</a>(<var data-name="defaultValue">defaultValue</var>)</span><ol>
<li>If <var data-name="defaultValue">defaultValue</var> is a ListValue:<ol>
<li>For each <var data-name="valueNode">valueNode</var> in <var data-name="defaultValue">defaultValue</var>:<ol>
<li>If <span class="spec-call"><a href="#ValidateDefaultValue()" data-name="ValidateDefaultValue">ValidateDefaultValue</a>(<var data-name="valueNode">valueNode</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="defaultValue">defaultValue</var> is an ObjectValue:<ol>
<li>Let <var data-name="objectFields">objectFields</var> be a list of all fields of <var data-name="defaultValue">defaultValue</var></li>
<li>Let <var data-name="fields">fields</var> be a list of all fields <var data-name="objectFields">objectFields</var> are refering to</li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>For each <var data-name="objectField">objectField</var> in <var data-name="objectFields">objectFields</var>:<ol>
<li>Let <var data-name="value">value</var> be the value of <var data-name="objectField">objectField</var></li>
<li>return <span class="spec-call"><a href="#ValidateDefaultValue()" data-name="ValidateDefaultValue">ValidateDefaultValue</a>(<var data-name="value">value</var>)</span></li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="defaultValue">defaultValue</var> is an EnumValue:<ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="defaultValue">defaultValue</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
</section>
<section id="sec-Default-Value-Uses-Internals.Explanatory-Text" class="subsec">
<h6><a href="#sec-Default-Value-Uses-Internals.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>A default value for an argument in a field must only reference enum values or a input fields that are exposed in the composed schema. This rule ensures that internal members are not exposed in the composed schema through default values.</p>
<p>In this example the <code>FOO</code> value in the <code>Enum1</code> enum is not marked with @internal, hence it doesn&rsquo;t violate the rule.</p>
<pre data-language="graphql"><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">type</span><span class="token punctuation">:</span> <span class="token class-name">Enum1</span> <span class="token operator">=</span> <span class="token constant">FOO</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Baz</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token constant">FOO</span>
  <span class="token constant">BAR</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This example is a violation of the rule because the default value for the field <code>field</code> in type <code>Input1</code> references an enum value (<code>FOO</code>) that is marked as <code>@internal</code>.</p>
<pre id="example-30183" class="spec-counter-example" data-language="graphql"><a href="#example-30183">Counter Example № 60</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">type</span><span class="token punctuation">:</span> <span class="token class-name">Input1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Baz</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token class-name">Enum1</span> <span class="token operator">=</span> <span class="token constant">FOO</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token constant">FOO</span> <span class="token directive function">@internal</span>
  <span class="token constant">BAR</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-fc715" class="spec-counter-example" data-language="graphql"><a href="#example-fc715">Counter Example № 61</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field</span><span class="token punctuation">(</span><span class="token attr-name">type</span><span class="token punctuation">:</span> <span class="token class-name">Input1</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token string">"ERROR"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Baz</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This example is a violation of the rule because the default value for the <code>type</code> argument in the <code>field</code> field references an enum value (<code>BAR</code>) that is marked as <code>@internal</code>.</p>
<p><code>graphql example counter-example type Query {   field(type: Enum1 = BAR): [Baz!]! }  enum Enum1 {   FOO   BAR @internal } </code></p>
</section>
</section>
<section id="sec-Empty-Merged-Enum-Type" secid="2.2.5.3">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Empty-Merged-Enum-Type">2.2.5.3</a></span>Empty Merged Enum Type</h4>
<section id="sec-Empty-Merged-Enum-Type.Error-Code" class="subsec">
<h6><a href="#sec-Empty-Merged-Enum-Type.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0009</p>
</section>
<section id="sec-Empty-Merged-Enum-Type.Formal-Specification" class="subsec">
<h6><a href="#sec-Empty-Merged-Enum-Type.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="enumsByName">enumsByName</var> be the set of all enums across all subgraphs involved in the schema composition grouped by their name.</li>
<li>For each <var data-name="enum">enum</var> in <var data-name="enumsByName">enumsByName</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="enum">enum</var>)</span> is true<ul>
<li><span class="spec-call"><a href="#IsEnumEmpty()" data-name="IsEnumEmpty">IsEnumEmpty</a>(<var data-name="enum">enum</var>)</span> must be false</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="IsEnumEmpty()">
<span class="spec-call"><a href="#IsEnumEmpty()" data-name="IsEnumEmpty">IsEnumEmpty</a>(<var data-name="enum">enum</var>)</span><ol>
<li>Let <var data-name="values">values</var> be a set of enum values for <var data-name="enum">enum</var> across all subgraphs</li>
<li>For each <var data-name="value">value</var> in <var data-name="values">values</var><ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="value">value</var>)</span> is true<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
</section>
<section id="sec-Empty-Merged-Enum-Type.Explanatory-Text" class="subsec">
<h6><a href="#sec-Empty-Merged-Enum-Type.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>If an enum type is defined in multiple subgraphs, only values not flagged as <code>@internal</code> in all subgraphs are included in the merged enum type. If this process results in an enum type with no values, the enum type is considered empty and invalid.</p>
<p>The following example shows a valid merged enum type. The <code>Enum1</code> type is defined in two subgraphs:</p>
<pre data-language="graphql"><code><span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span> <span class="token directive function">@internal</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This counter-example shows an invalid merged enum type. The <code>Enum1</code> type is defined in two subgraphs, but the <code>Value1</code> and <code>Value2</code> values are flagged as <code>@internal</code> in one of the subgraphs:</p>
<pre id="example-eb048" class="spec-counter-example" data-language="graphql"><a href="#example-eb048">Counter Example № 62</a><code><span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span> <span class="token directive function">@internal</span>
  <span class="token property">Value2</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter-example, the <code>Enum1</code> type is defined in two subgraphs, but the <code>Value1</code> value is flagged as <code>@internal</code> in one of the subgraphs and the <code>Value2</code> value is flagged as <code>@internal</code> in the other subgraph which results in an empty merged enum type:</p>
<pre id="example-47785" class="spec-counter-example" data-language="graphql"><a href="#example-47785">Counter Example № 63</a><code><span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span> <span class="token directive function">@internal</span>
  <span class="token property">Value2</span>
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token class-name">Enum1</span> <span class="token punctuation">{</span>
  <span class="token property">Value1</span>
  <span class="token property">Value2</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Interface" secid="2.2.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Interface">2.2.6</a></span>Interface</h3>
<section id="sec-Empty-Merged-Interface-Type" secid="2.2.6.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Empty-Merged-Interface-Type">2.2.6.1</a></span>Empty Merged Interface Type</h4>
<section id="sec-Empty-Merged-Interface-Type.Error-Code" class="subsec">
<h6><a href="#sec-Empty-Merged-Interface-Type.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0018</p>
</section>
<section id="sec-Empty-Merged-Interface-Type.Formal-Specification" class="subsec">
<h6><a href="#sec-Empty-Merged-Interface-Type.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="interfaces">interfaces</var> be the set of all interface types across all subgraphs.</li>
<li>For each <var data-name="interface">interface</var> in <var data-name="interfaces">interfaces</var>:<ul>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="interface">interface</var>)</span> is true<ul>
<li><span class="spec-call"><a href="#IsInterfaceTypeEmpty()" data-name="IsInterfaceTypeEmpty">IsInterfaceTypeEmpty</a>(<var data-name="interface">interface</var>)</span> must be false.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="spec-algo" id="IsInterfaceTypeEmpty()">
<span class="spec-call"><a href="#IsInterfaceTypeEmpty()" data-name="IsInterfaceTypeEmpty">IsInterfaceTypeEmpty</a>(<var data-name="interface">interface</var>)</span><ol>
<li>Let <var data-name="fields">fields</var> be a set of all fields across all subgraphs with coordinate and kind of <var data-name="interface">interface</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="fields">fields</var>:<ol>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="field">field</var>)</span> is true<ol>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
</section>
<section id="sec-Empty-Merged-Interface-Type.Explanatory-Text" class="subsec">
<h6><a href="#sec-Empty-Merged-Interface-Type.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>When an interface type is defined in multiple subgraphs, only common fields and fields not flagged as <code>@internal</code> are included in the merged interface type. If this process results in an interface type with no fields, the interface type is considered empty and invalid.</p>
<p>In the following example, the merged interface type <code>Interface1</code> is valid. The type is defined in two subgraphs:</p>
<pre id="example-07ec0" class="spec-example" data-language="graphql"><a href="#example-07ec0">Example № 64</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged interface type <code>Interface1</code> is valid and contains <code>field1</code> as it exists in both subgraphs. The type is defined in two subgraphs:</p>
<pre id="example-0dba8" class="spec-example" data-language="graphql"><a href="#example-0dba8">Example № 65</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged interface type <code>Interface1</code> is invalid. The type is defined in two subgraphs, but do not have any common fields:</p>
<pre id="example-cb8b1" class="spec-counter-example" data-language="graphql"><a href="#example-cb8b1">Counter Example № 66</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This counter-example shows an invalid merged interface type. The <code>Interface1</code> type is defined in two subgraphs, but both <code>field1</code> and <code>field2</code> are flagged as <code>@internal</code> in one of the subgraphs:</p>
<pre id="example-eb352" class="spec-counter-example" data-language="graphql"><a href="#example-eb352">Counter Example № 67</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this counter-example, the <code>Interface1</code> type is defined in two subgraphs, but <code>field1</code> is flagged as <code>@internal</code> in one subgraph and <code>field2</code> is flagged as <code>@internal</code> in the other subgraph, resulting in an empty merged interface type:</p>
<pre id="example-802ec" class="spec-counter-example" data-language="graphql"><a href="#example-802ec">Counter Example № 68</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the following example, the merged interface type <code>Interface1</code> is invalid. The type is defined in two subgraphs, but the common field <code>field1</code> is flagged as <code>@internal</code> in one of the subgraphs:</p>
<pre id="example-fd673" class="spec-counter-example" data-language="graphql"><a href="#example-fd673">Counter Example № 69</a><code><span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Union" secid="2.2.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Union">2.2.7</a></span>Union</h3>
<section id="sec-Union-Type-Members-Cannot-Reference-Internals" secid="2.2.7.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Union-Type-Members-Cannot-Reference-Internals">2.2.7.1</a></span>Union Type Members Cannot Reference Internals</h4>
<section id="sec-Union-Type-Members-Cannot-Reference-Internals.Error-Code" class="subsec">
<h6><a href="#sec-Union-Type-Members-Cannot-Reference-Internals.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0017</p>
</section>
<section id="sec-Union-Type-Members-Cannot-Reference-Internals.Formal-Specification" class="subsec">
<h6><a href="#sec-Union-Type-Members-Cannot-Reference-Internals.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="subgraphs">subgraphs</var> be a list of all subgraphs.</li>
<li>For each <var data-name="subgraph">subgraph</var> in <var data-name="subgraphs">subgraphs</var>:<ul>
<li>Let <var data-name="unionTypes">unionTypes</var> be the set of all union types in <var data-name="subgraph">subgraph</var>.</li>
<li>For each <var data-name="unionType">unionType</var> in <var data-name="unionTypes">unionTypes</var>:<ul>
<li>Let <var data-name="members">members</var> be the set of member types of <var data-name="unionType">unionType</var></li>
<li>For each <var data-name="member">member</var> in <var data-name="members">members</var>:<ul>
<li>Let <var data-name="type">type</var> be the type of <var data-name="member">member</var></li>
<li><span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="type">type</var>)</span> must be true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-Union-Type-Members-Cannot-Reference-Internals.Explanatory-Text" class="subsec">
<h6><a href="#sec-Union-Type-Members-Cannot-Reference-Internals.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>A union type must not include members where the type is marked as <code>@internal</code> in any subgraph. This rule ensures that the composed schema does not expose internal types.</p>
<p>Here is a valid example where all member types of a union are public:</p>
<pre id="example-d052e" class="spec-example" data-language="graphql"><a href="#example-d052e">Example № 70</a><code><span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">union</span> <span class="token class-name">Union1</span> <span class="token operator">=</span> <span class="token property">Object1</span> <span class="token operator">|</span> <span class="token property">Object2</span>

<span class="token keyword">type</span> <span class="token class-name">Object3</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field3</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token keyword">union</span> <span class="token class-name">Union1</span> <span class="token operator">=</span> <span class="token property">Object3</span>
</code></pre>
<p>In this counter-example, the member type <code>Object2</code> is marked as <code>@internal</code> in the second subgraph, so the composed schema is invalid:</p>
<pre id="example-c38ef" class="spec-counter-example" data-language="graphql"><a href="#example-c38ef">Counter Example № 71</a><code><span class="token keyword">union</span> <span class="token class-name">Union1</span> <span class="token operator">=</span> <span class="token property">Object1</span> <span class="token operator">|</span> <span class="token property">Object2</span>

<span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">union</span> <span class="token class-name">Union1</span> <span class="token operator">=</span> <span class="token property">Object1</span> <span class="token operator">|</span> <span class="token property">Object2</span>

<span class="token keyword">type</span> <span class="token class-name">Object1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Object2</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
  <span class="token attr-name">field4</span><span class="token punctuation">:</span> <span class="token scalar">Float</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Schema" secid="2.2.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Schema">2.2.8</a></span>Schema</h3>
<section id="sec-No-Queries" secid="2.2.8.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-No-Queries">2.2.8.1</a></span>No Queries</h4>
<section id="sec-No-Queries.Error-Code" class="subsec">
<h6><a href="#sec-No-Queries.Error-Code" title="link to this subsection">Error Code</a></h6>
<p>F0007</p>
</section>
<section id="sec-No-Queries.Formal-Specification" class="subsec">
<h6><a href="#sec-No-Queries.Formal-Specification" title="link to this subsection">Formal Specification</a></h6>
<ul>
<li>Let <var data-name="schemas">schemas</var> be the set of all subgraph schemas involved in the composition</li>
<li><span class="spec-call"><a href="#HasQueryRootType()" data-name="HasQueryRootType">HasQueryRootType</a>(<var data-name="schemas">schemas</var>)</span> must be true</li>
</ul>
<div class="spec-algo" id="HasQueryRootType()">
<span class="spec-call"><a href="#HasQueryRootType()" data-name="HasQueryRootType">HasQueryRootType</a>(<var data-name="schemas">schemas</var>)</span><ol>
<li>for each <var data-name="schema">schema</var> in <var data-name="schemas">schemas</var><ol>
<li>let <var data-name="queryRootType">queryRootType</var> be the query root type of <var data-name="schema">schema</var></li>
<li>let <var data-name="fields">fields</var> be the fields of <var data-name="queryRootType">queryRootType</var></li>
<li>if <var data-name="fields">fields</var> is not empty<ol>
<li>return true</li>
</ol>
</li>
</ol>
</li>
<li>return false</li>
</ol>
</div>
</section>
<section id="sec-No-Queries.Explanatory-Text" class="subsec">
<h6><a href="#sec-No-Queries.Explanatory-Text" title="link to this subsection">Explanatory Text</a></h6>
<p>A schema composed from multiple subgraphs must have a query root type to be valid. The query root type is essential. This rule ensures that at least one subgraph in the composition defines a query root type that defines at least one query field.</p>
<p>The examples provided in the test cases demonstrate how the absence or presence of a valid query root type impacts the composition result. A composition that does not meet this requirement should result in an error with the code F0007, indicating the need for at least one query field across the included subgraphs.</p>
<pre data-language="graphql"><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@remove</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the example, both <code>field1</code> and <code>field2</code> are marked for removal, leaving no valid query fields:</p>
<pre id="example-2e240" class="spec-counter-example" data-language="graphql"><a href="#example-2e240">Counter Example № 72</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@remove</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token directive function">@remove</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field2</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this case, the presence of <code>@internal</code> on <code>field</code>1 removes the field from the composed schema, leaving no accessible query fields.</p>
<pre id="example-e2b0e" class="spec-counter-example" data-language="graphql"><a href="#example-e2b0e">Counter Example № 73</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
</section>
<section id="sec-Shared-Functions" secid="2.2.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Shared-Functions">2.2.9</a></span>Shared Functions</h3>
<section id="sec-Same-Type-Shape" secid="2.2.9.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Same-Type-Shape">2.2.9.1</a></span>Same Type Shape</h4>
<p>If types differ only in nullability they are still considered mergable. This algorithm determines if two types are mergable by removing non-nullibility from the types when comparing them.</p>
<div class="spec-algo" id="SameTypeShape()">
<span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> is Non-Null:<ol>
<li>If <var data-name="typeB">typeB</var> is nullable<ol>
<li>Let <var data-name="innerType">innerType</var> be the inner type of <var data-name="typeA">typeA</var>.</li>
<li>return <span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="innerType">innerType</var>, <var data-name="typeB">typeB</var>)</span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="typeB">typeB</var> is Non-Null:<ol>
<li>If <var data-name="typeA">typeA</var> is nullable<ol>
<li>Let <var data-name="innerType">innerType</var> be the inner type of <var data-name="typeB">typeB</var>.</li>
<li>return <span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="typeA">typeA</var>, <var data-name="innerType">innerType</var>)</span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> is List:<ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> is not List<ol>
<li>return false.</li>
</ol>
</li>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the item type of <var data-name="typeA">typeA</var>.</li>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the item type of <var data-name="typeB">typeB</var>.</li>
<li>return <span class="spec-call"><a href="#SameTypeShape()" data-name="SameTypeShape">SameTypeShape</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span>.</li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are not of the same kind<ol>
<li>return false.</li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> do not have the same name<ol>
<li>return false.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Is-Exposed" secid="2.2.9.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-Is-Exposed">2.2.9.2</a></span>Is Exposed</h4>
<div class="spec-algo" id="IsExposed()">
<span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="member">member</var>)</span><ol>
<li>Let <var data-name="members">members</var> be a list of all members across all subgraphs with the same coordinate and kind as <var data-name="member">member</var></li>
<li>If any <var data-name="members">members</var> is marked with <code>@internal</code><ol>
<li>return false</li>
</ol>
</li>
<li>If <var data-name="member">member</var> is InputField<ol>
<li>Let <var data-name="type">type</var> be any input object type that <var data-name="member">member</var> is declared on</li>
<li>if <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="type">type</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
<li>Let <var data-name="types">types</var> be the list of all types across all subgraphs with the same coordinate and kind as <var data-name="type">type</var></li>
<li>If <var data-name="member">member</var> is in <span class="spec-call"><a href="#CommonFields()" data-name="CommonFields">CommonFields</a>(<var data-name="types">types</var>)</span><ol>
<li>return true</li>
</ol>
</li>
<li>return false</li>
</ol>
</li>
<li>If <var data-name="member">member</var> is EnumValue<ol>
<li>Let <var data-name="enum">enum</var> be any enum that <var data-name="member">member</var> is declared on</li>
<li>return <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="enum">enum</var>)</span></li>
</ol>
</li>
<li>If <var data-name="member">member</var> is ObjectField<ol>
<li>Let <var data-name="type">type</var> be the any type that <var data-name="member">member</var> is declared on</li>
<li>return <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="type">type</var>)</span></li>
</ol>
</li>
<li>If <var data-name="member">member</var> is InterfaceField<ol>
<li>Let <var data-name="type">type</var> be the any type that <var data-name="member">member</var> is declared on</li>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="type">type</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
<li>Let <var data-name="types">types</var> be the list of all types across all subgraphs with the same coordinate and kind as <var data-name="type">type</var></li>
<li>If <var data-name="member">member</var> is in <span class="spec-call"><a href="#CommonFields()" data-name="CommonFields">CommonFields</a>(<var data-name="types">types</var>)</span><ol>
<li>return true</li>
</ol>
</li>
<li>return false</li>
</ol>
</li>
<li>If <var data-name="member">member</var> is Argument<ol>
<li>If <var data-name="member">member</var> is declared on a field:<ol>
<li>Let <var data-name="declaringField">declaringField</var> be any field that <var data-name="member">member</var> is declared on</li>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="declaringField">declaringField</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
<li>Let <var data-name="declaringFields">declaringFields</var> be the list of all fields across all subgraphs with the same coordinate and kind as <var data-name="declaringField">declaringField</var></li>
<li>If <var data-name="member">member</var> is in <span class="spec-call"><a href="#CommonArguments()" data-name="CommonArguments">CommonArguments</a>(<var data-name="declaringFields">declaringFields</var>)</span><ol>
<li>return true</li>
</ol>
</li>
<li>return false</li>
</ol>
</li>
<li>If <var data-name="member">member</var> is declared on a directive<ol>
<li>Let <var data-name="declaringDirective">declaringDirective</var> be any directive that <var data-name="member">member</var> is declared on</li>
<li>If <span class="spec-call"><a href="#IsExposed()" data-name="IsExposed">IsExposed</a>(<var data-name="declaringDirective">declaringDirective</var>)</span> is false<ol>
<li>return false</li>
</ol>
</li>
<li>Let <var data-name="declaringDirectives">declaringDirectives</var> be the list of any directives across all subgraphs with the same coordiante and kind as <var data-name="declaringDirective">declaringDirective</var></li>
<li>If <var data-name="member">member</var> is in <span class="spec-call"><a href="#CommonArguments()" data-name="CommonArguments">CommonArguments</a>(<var data-name="declaringDirectives">declaringDirectives</var>)</span><ol>
<li>return true</li>
</ol>
</li>
<li>return false</li>
</ol>
</li>
</ol>
</li>
<li>return true</li>
</ol>
</div>
<div class="spec-algo" id="CommonArguments()">
<span class="spec-call"><a href="#CommonArguments()" data-name="CommonArguments">CommonArguments</a>(<var data-name="members">members</var>)</span><ol>
<li>Let <var data-name="commonArguments">commonArguments</var> be the set of all arguments of all <var data-name="members">members</var> across all subgraphs</li>
<li>For each <var data-name="member">member</var> in <var data-name="members">members</var><ol>
<li>Let <var data-name="arguments">arguments</var> be the set of all arguments of <var data-name="member">member</var></li>
<li>Let <var data-name="commonArguments">commonArguments</var> be the intersection of <var data-name="commonArguments">commonArguments</var> and <var data-name="arguments">arguments</var></li>
</ol>
</li>
<li>return <var data-name="commonArguments">commonArguments</var></li>
</ol>
</div>
<div class="spec-algo" id="CommonFields()">
<span class="spec-call"><a href="#CommonFields()" data-name="CommonFields">CommonFields</a>(<var data-name="members">members</var>)</span><ol>
<li>Let <var data-name="commonFields">commonFields</var> be the set of all fields of all <var data-name="members">members</var> across all subgraphs</li>
<li>For each <var data-name="member">member</var> in <var data-name="members">members</var><ol>
<li>Let <var data-name="fields">fields</var> be the set of all fields of <var data-name="member">member</var></li>
<li>Let <var data-name="commonFields">commonFields</var> be the intersection of <var data-name="commonFields">commonFields</var> and <var data-name="fields">fields</var></li>
</ol>
</li>
<li>return <var data-name="commonFields">commonFields</var></li>
</ol>
</div>
</section>
</section>
</section>
<section id="sec-Compose" secid="2.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Compose">2.3</a></span>Compose</h2>
<p>To compose a gateway configuration the composition tooling must have loaded at least one subgraph configuration.</p>
<div class="spec-algo" id="ComposeConfiguration()">
<span class="spec-call"><a href="#ComposeConfiguration()" data-name="ComposeConfiguration">ComposeConfiguration</a>(<var data-name="subgraphConfigurations">subgraphConfigurations</var>)</span><ol>
<li>For each <var data-name="subgraphConfiguration">subgraphConfiguration</var> in <var data-name="subgraphConfigurations">subgraphConfigurations</var>:</li>
<li>Let <var data-name="subgraphSchema">subgraphSchema</var> be the result of <span class="spec-call"><a href="#BuildSubgraphSchema()" data-name="BuildSubgraphSchema">BuildSubgraphSchema</a>(<var data-name="subgraphConfiguration">subgraphConfiguration</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="BuildSubgraphSchema()">
<span class="spec-call"><a href="#BuildSubgraphSchema()" data-name="BuildSubgraphSchema">BuildSubgraphSchema</a>(<var data-name="subgraphConfiguration">subgraphConfiguration</var>)</span><ol>
<li>Todo</li>
</ol>
</div>
<div class="spec-algo" id="MergeType()">
<span class="spec-call"><a href="#MergeType()" data-name="MergeType">MergeType</a>(<var data-name="typesOrTypeExtensions">typesOrTypeExtensions</var>)</span><ol>
<li>Todo</li>
</ol>
</div>
<div class="spec-algo" id="MergeSchema()">
<span class="spec-call"><a href="#MergeSchema()" data-name="MergeSchema">MergeSchema</a>(<var data-name="schemaA">schemaA</var>, <var data-name="schemaB">schemaB</var>)</span><ol>
<li>Let <var data-name="mergedSchema">mergedSchema</var> be an empty SchemaDefinition</li>
<li>Let <var data-name="queryTypeA">queryTypeA</var> be the query type of <var data-name="schemaA">schemaA</var></li>
<li>Set <var data-name="mergedSchema">mergedSchema</var> to have query type <var data-name="queryTypeA">queryTypeA</var></li>
<li>Let <var data-name="mutationTypeA">mutationTypeA</var> be the mutation type of <var data-name="schemaA">schemaA</var> or null</li>
<li>Let <var data-name="mutationTypeB">mutationTypeB</var> be the mutation type of <var data-name="schemaB">schemaB</var> or null</li>
<li>If <var data-name="mutationTypeA">mutationTypeA</var> is not null<ol>
<li>Set <var data-name="mergedSchema">mergedSchema</var> to have mutation type <var data-name="mutationTypeA">mutationTypeA</var></li>
</ol>
</li>
<li>If <var data-name="mutationTypeA">mutationTypeA</var> is null and <var data-name="mutationTypeB">mutationTypeB</var> is not null<ol>
<li>Set <var data-name="mergedSchema">mergedSchema</var> to have mutation type <var data-name="mutationTypeB">mutationTypeB</var></li>
</ol>
</li>
<li>Let <var data-name="subscriptionTypeA">subscriptionTypeA</var> be the subscription type of <var data-name="schemaA">schemaA</var> or null</li>
<li>Let <var data-name="subscriptionTypeB">subscriptionTypeB</var> be the subscription type of <var data-name="schemaB">schemaB</var> or null</li>
<li>If <var data-name="subscriptionTypeA">subscriptionTypeA</var> is not null<ol>
<li>Set <var data-name="mergedSchema">mergedSchema</var> to have subscription type <var data-name="subscriptionTypeA">subscriptionTypeA</var></li>
</ol>
</li>
<li>If <var data-name="subscriptionTypeA">subscriptionTypeA</var> is null and <var data-name="subscriptionTypeB">subscriptionTypeB</var> is not null<ol>
<li>Set <var data-name="mergedSchema">mergedSchema</var> to have subscription type <var data-name="subscriptionTypeB">subscriptionTypeB</var></li>
</ol>
</li>
<li>return <var data-name="mergedSchema">mergedSchema</var></li>
</ol>
</div>
<section id="sec-MergeObjectType" secid="2.3.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeObjectType">2.3.1</a></span>MergeObjectType</h3>
<p>This algorithm combines two object types from different subgraphs into a single object type. It does this only if neither type is marked as <code>@internal</code>, ensuring internal types remain private.</p>
<p>This algorithm creates a merged output type containing all the fields from both types, unless they are marked as <code>@internal</code>. When the same field exists in both types, it merges these fields into one.</p>
<p>The fields are merged by name, and the merged field is the result of calling <span class="spec-call"><a href="#MergeOutputField()" data-name="MergeOutputField">MergeOutputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span>.</p>
<div class="spec-algo" id="MergeOutputType()">
<span class="spec-call"><a href="#MergeOutputType()" data-name="MergeOutputType">MergeOutputType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> are <code>@internal</code><ol>
<li>return null</li>
</ol>
</li>
<li>Let <var data-name="outputType">outputType</var> be an empty OutputObjectTypeDefinition</li>
<li>Let <var data-name="fields">fields</var> be a set of field names that are defined on either typeA or typeB</li>
<li>For each <var data-name="fieldName">fieldName</var> in <var data-name="fields">fields</var>:<ol>
<li>Let <var data-name="fieldA">fieldA</var> be the field with the same name on typeA</li>
<li>Let <var data-name="fieldB">fieldB</var> be the field with the same name on typeB</li>
<li>If <var data-name="fieldA">fieldA</var> or <var data-name="fieldB">fieldB</var> are <code>@internal</code><ol>
<li>continue</li>
</ol>
</li>
<li>If <var data-name="fieldB">fieldB</var> is null<ol>
<li>Append <var data-name="fieldA">fieldA</var> to <var data-name="outputType">outputType</var></li>
<li>continue</li>
</ol>
</li>
<li>If <var data-name="fieldA">fieldA</var> is null<ol>
<li>Append <var data-name="fieldB">fieldB</var> to <var data-name="outputType">outputType</var></li>
<li>continue</li>
</ol>
</li>
<li>Let <var data-name="mergedField">mergedField</var> be the result of calling <span class="spec-call"><a href="#MergeOutputField()" data-name="MergeOutputField">MergeOutputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span></li>
<li>Append <var data-name="mergedField">mergedField</var> to <var data-name="outputType">outputType</var></li>
</ol>
</li>
<li>Set <var data-name="outputType">outputType</var> to have the same name as <var data-name="typeA">typeA</var></li>
<li>Set <var data-name="outputType">outputType</var> to have <span class="spec-call"><a href="#MergeInterfaceImplementation()" data-name="MergeInterfaceImplementation">MergeInterfaceImplementation</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span> as its interfaces</li>
<li>return <var data-name="outputType">outputType</var></li>
</ol>
</div>
<p><em>Examples of Merging Output Object Types:</em></p>
<pre id="example-6b20b" class="spec-example" data-language="graphql"><a href="#example-6b20b">Example № 74</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result </span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging Output Object Types with <code>@internal</code> Fields:</em></p>
<pre id="example-dba5f" class="spec-example" data-language="graphql"><a href="#example-dba5f">Example № 75</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">internalField</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeInputType" secid="2.3.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeInputType">2.3.2</a></span>MergeInputType</h3>
<p>This algorithm merges two input object types from different subgraphs. It excludes any type marked with <code>@internal</code>, ensuring internal types are not exposed in the merged schema. </p>
<p>The fields of the merged input object type are the intersection of the fields of the input object types from the subgraphs. This approach ensures that the merged input object type is compatible with both subgraphs.</p>
<p>The fields are merged by name, and the merged field is the result of calling <span class="spec-call"><a href="#MergeInputField()" data-name="MergeInputField">MergeInputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span>.</p>
<div class="spec-algo" id="MergeInputType()">
<span class="spec-call"><a href="#MergeInputType()" data-name="MergeInputType">MergeInputType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> are <code>@internal</code><ol>
<li>return null</li>
</ol>
</li>
<li>Let <var data-name="inputType">inputType</var> be an empty InputObjectTypeDefinition</li>
<li>Let <var data-name="commonFields">commonFields</var> be the set of fields names that are defined on both <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var></li>
<li>For each <var data-name="field">field</var> in <var data-name="commonFields">commonFields</var>:<ol>
<li>Let <var data-name="fieldA">fieldA</var> be the field with the same name on <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="fieldB">fieldB</var> be the field with the same name on <var data-name="typeB">typeB</var></li>
<li>If <var data-name="fieldA">fieldA</var> or <var data-name="fieldB">fieldB</var> are <code>@internal</code><ol>
<li>continue</li>
</ol>
</li>
<li>Let <var data-name="mergedField">mergedField</var> be the result of calling <span class="spec-call"><a href="#MergeInputField()" data-name="MergeInputField">MergeInputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span></li>
<li>Append <var data-name="mergedField">mergedField</var> to <var data-name="inputType">inputType</var></li>
</ol>
</li>
<li>Set <var data-name="inputType">inputType</var> to have the same name as <var data-name="typeA">typeA</var></li>
<li>return <var data-name="inputType">inputType</var></li>
</ol>
</div>
<p><em>Merging Common Input Object Fields:</em></p>
<pre id="example-f8f37" class="spec-example" data-language="graphql"><a href="#example-f8f37">Example № 76</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># Merged Input Object</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging Common Input Object Fields with <code>@internal</code> Fields:</em></p>
<pre id="example-bc08b" class="spec-example" data-language="graphql"><a href="#example-bc08b">Example № 77</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">internalField</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">internalField</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> 
<span class="token punctuation">}</span>

<span class="token comment"># Merged Input Object</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeInterfaceType" secid="2.3.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeInterfaceType">2.3.3</a></span>MergeInterfaceType</h3>
<p>This algorithm merges two interface types from different subgraphs, given that neither type is marked as <code>@internal</code>.</p>
<p>The resulting interface type is the intersection of the fields of the interface types from the subgraphs. This approach ensures that the merged interface type is compatible with object types from both subgraphs. </p>
<p>The fields are merged by name, and the merged field is the result of calling <span class="spec-call"><a href="#MergeOutputField()" data-name="MergeOutputField">MergeOutputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span>.</p>
<div class="spec-algo" id="MergeInterfaceType()">
<span class="spec-call"><a href="#MergeInterfaceType()" data-name="MergeInterfaceType">MergeInterfaceType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> are <code>@internal</code><ol>
<li>return null</li>
</ol>
</li>
<li>Let <var data-name="interfaceType">interfaceType</var> be an empty InterfaceTypeDefinition</li>
<li>Let <var data-name="fields">fields</var> be a set of common field names that are defined in <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var></li>
<li>For each <var data-name="fieldName">fieldName</var> in <var data-name="fields">fields</var>:<ol>
<li>Let <var data-name="fieldA">fieldA</var> be the field with the same name on <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="fieldB">fieldB</var> be the field with the same name on <var data-name="typeB">typeB</var></li>
<li>If <var data-name="fieldA">fieldA</var> or <var data-name="fieldB">fieldB</var> are <code>@internal</code><ol>
<li>continue</li>
</ol>
</li>
<li>Let <var data-name="mergedField">mergedField</var> be the result of calling <span class="spec-call"><a href="#MergeOutputField()" data-name="MergeOutputField">MergeOutputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span></li>
<li>Append <var data-name="mergedField">mergedField</var> to <var data-name="interfaceType">interfaceType</var></li>
</ol>
</li>
<li>Set <var data-name="interfaceType">interfaceType</var> to have the same name as <var data-name="typeA">typeA</var></li>
<li>Set <var data-name="interfaceType">interfaceType</var> to have <span class="spec-call"><a href="#MergeInterfaceImplementation()" data-name="MergeInterfaceImplementation">MergeInterfaceImplementation</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span> as its interfaces</li>
<li>return <var data-name="interfaceType">interfaceType</var></li>
</ol>
</div>
<p><em>Merging Common Fields:</em></p>
<pre id="example-260d7" class="spec-example" data-language="graphql"><a href="#example-260d7">Example № 78</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueField</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># Merged Interface</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging Common Fields with <code>@internal</code> Fields:</em></p>
<pre id="example-24eb4" class="spec-example" data-language="graphql"><a href="#example-24eb4">Example № 79</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">internalField</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token directive function">@internal</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">internalField</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> 
<span class="token punctuation">}</span>

<span class="token comment"># Merged Interface</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This counter example shows why it is important that the gateway uses the intersection rather than the union of the fields of the interface types from the subgraphs:</p>
<pre id="example-0e171" class="spec-counter-example" data-language="graphql"><a href="#example-0e171">Counter Example № 80</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ObjectA</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># Merged Interface</span>

<span class="token keyword">interface</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
  <span class="token attr-name">uniqueFieldB</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span>
<span class="token punctuation">}</span>

<span class="token comment"># This object type is no longer compatible with the merged interface types as it is </span>
<span class="token comment"># missing the `uniqueFieldB` field.</span>
<span class="token keyword">type</span> <span class="token class-name">ObjectA</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceA</span> <span class="token punctuation">{</span> 
  <span class="token attr-name">commonField</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">uniqueFieldA</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeUnionType" secid="2.3.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeUnionType">2.3.4</a></span>MergeUnionType</h3>
<p>This algorithm is used to merge two union types from separate subgraphs. It combines the members from both union types into a new union type by name, given neither original type is marked as <code>@internal</code>. </p>
<p>This algorithm has to combine the members of both types, because otherwise there is the possibility of invalid states during the execution. If members were removed from the union type, the subgraph could still return it as a result of a query, which would be invalid in the composed schema.</p>
<div class="spec-algo" id="MergeUnionType()">
<span class="spec-call"><a href="#MergeUnionType()" data-name="MergeUnionType">MergeUnionType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> are <code>@internal</code><ol>
<li>return null</li>
</ol>
</li>
<li>Let <var data-name="unionType">unionType</var> be an empty UnionTypeDefinition</li>
<li>Let <var data-name="types">types</var> be a set of type names that are defined on either <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var></li>
<li>Set <var data-name="unionType">unionType</var> to have the same name as <var data-name="typeA">typeA</var></li>
<li>Set <var data-name="types">types</var> to be the types of <var data-name="unionType">unionType</var></li>
<li>return <var data-name="unionType">unionType</var></li>
</ol>
</div>
<p><em>Merging Union Types:</em></p>
<pre data-language="graphql"><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type1</span> <span class="token operator">|</span> <span class="token property">Type2</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type2</span> <span class="token operator">|</span> <span class="token property">Type3</span>

<span class="token comment"># Result </span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type1</span> <span class="token operator">|</span> <span class="token property">Type2</span> <span class="token operator">|</span> <span class="token property">Type3</span>
</code></pre>
<p><em>Merging Union Types with <code>@internal</code>:</em></p>
<pre data-language="graphql"><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type1</span> <span class="token operator">|</span> <span class="token property">Type2</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token directive function">@internal</span> <span class="token operator">=</span> <span class="token property">Type2</span> <span class="token operator">|</span> <span class="token property">Type3</span>

<span class="token comment"># Result</span>
<span class="token property">null</span>
</code></pre>
<p>The following counter-example shows a invalid composition. Subgraph A could still return <code>Type1</code> for the field <code>field1</code>, which would lead to an execution error:</p>
<pre id="example-f19a4" class="spec-counter-example" data-language="graphql"><a href="#example-f19a4">Counter Example № 81</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type1</span> <span class="token operator">|</span> <span class="token property">Type2</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">UnionTypeA</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type2</span> 

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">UnionTypeA</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">union</span> <span class="token class-name">UnionTypeA</span> <span class="token operator">=</span> <span class="token property">Type2</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">UnionTypeA</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeEnumType" secid="2.3.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeEnumType">2.3.5</a></span>MergeEnumType</h3>
<p>This algorithm merges two enum types from different subgraphs into one, given if neither is marked as <code>@internal</code>. This process simply retains the enum values from <var data-name="typeA">typeA</var> for the merged enum type as <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are guaranteed to have the same values because <a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs">Values Must Be The Same Across Subgraphs</a></p>
<p>Since enum types can be used both as input and output types, they must be strictly equal in both subgraphs. This strict equality rule avoids any invalid states that could arise from using either an intersection or union of the enum values.</p>
<div class="spec-algo" id="MergeEnumType()">
<span class="spec-call"><a href="#MergeEnumType()" data-name="MergeEnumType">MergeEnumType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var> are <code>@internal</code><ol>
<li>return null</li>
</ol>
</li>
<li>Let <var data-name="enumType">enumType</var> be an empty EnumTypeDefinition</li>
<li>Let <var data-name="valuesOfA">valuesOfA</var> be the set of enum values defined on <var data-name="typeA">typeA</var></li>
<li>Set <var data-name="enumType">enumType</var> to have the same name as <var data-name="typeA">typeA</var></li>
<li>Set <var data-name="valuesOfA">valuesOfA</var> to be the values of <var data-name="enumType">enumType</var></li>
<li>return <var data-name="enumType">enumType</var></li>
</ol>
</div>
<p><em>Examples of Merging Enum Types:</em></p>
<pre data-language="graphql"><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumTypeA</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumTypeA</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumTypeA</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The following counter-example shows an invalid composition that uses the union merge approach. A query to subgraph B could use <code>VALUE1</code> in <code>field1</code> which would lead to an execution error:</p>
<pre id="example-3c5d0" class="spec-counter-example" data-language="graphql"><a href="#example-3c5d0">Counter Example № 82</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">EnumType1</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">EnumType1</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The following counter-example shows an invalid composition that uses the intersection merge approach. A query to subgraph A could return <code>VALUE2</code> in <code>field1</code> which would lead to an execution error:</p>
<pre id="example-1f2b4" class="spec-counter-example" data-language="graphql"><a href="#example-1f2b4">Counter Example № 83</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">EnumType1</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">enum</span> <span class="token class-name">EnumType1</span> <span class="token punctuation">{</span>
  <span class="token constant">VALUE1</span>
  <span class="token constant">VALUE2</span>
<span class="token punctuation">}</span>

<span class="token keyword">input</span> <span class="token object">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token class-name">EnumType1</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeInputField" secid="2.3.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeInputField">2.3.6</a></span>MergeInputField</h3>
<p>This algorithm merges two input fields from the same type of different subgraphs into one. The algorithm expects that both fields have the same schema coordinate. The type of the field is the result of calling <span class="spec-call"><a href="#MergeInputFieldType()" data-name="MergeInputFieldType">MergeInputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span>.</p>
<div class="spec-algo" id="MergeInputField()">
<span class="spec-call"><a href="#MergeInputField()" data-name="MergeInputField">MergeInputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span><ol>
<li>Let <var data-name="mergedField">mergedField</var> be an empty InputFieldDefinition</li>
<li>Let <var data-name="typeA">typeA</var> be the type of fieldA</li>
<li>Let <var data-name="typeB">typeB</var> be the type of fieldB</li>
<li>Let <var data-name="mergedType">mergedType</var> be the result of calling <span class="spec-call"><a href="#MergeInputFieldType()" data-name="MergeInputFieldType">MergeInputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span></li>
<li>Set <var data-name="mergedField">mergedField</var> to have the same name as <var data-name="fieldA">fieldA</var></li>
<li>Set <var data-name="mergedField">mergedField</var> to have <var data-name="mergedType">mergedType</var> as its type</li>
<li>return <var data-name="mergedField">mergedField</var></li>
</ol>
</div>
<p><em>Merging Input Fields:</em></p>
<pre id="example-ca321" class="spec-example" data-language="graphql"><a href="#example-ca321">Example № 84</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">input</span> <span class="token object">InputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeOutputField" secid="2.3.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeOutputField">2.3.7</a></span>MergeOutputField</h3>
<p>This algorithm merges two output fields from the same type of different subgraphs into one. The algorithm expects that both fields have the same schema coordinate. The arguments of both fields are merged based on <span class="spec-call"><a href="#MergeArguments()" data-name="MergeArguments">MergeArguments</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span>. The type of the field is the result of calling <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span>.</p>
<div class="spec-algo" id="MergeOutputField()">
<span class="spec-call"><a href="#MergeOutputField()" data-name="MergeOutputField">MergeOutputField</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span><ol>
<li>Let <var data-name="mergedField">mergedField</var> be an empty OutputFieldDefinition</li>
<li>Let <var data-name="typeA">typeA</var> be the type of fieldA</li>
<li>Let <var data-name="typeB">typeB</var> be the type of fieldB</li>
<li>Let <var data-name="mergedType">mergedType</var> be the result of calling <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span></li>
<li>Set <var data-name="mergedField">mergedField</var> to have the same name as <var data-name="fieldA">fieldA</var></li>
<li>Set <var data-name="mergedField">mergedField</var> to have <var data-name="mergedType">mergedType</var> as its type</li>
<li>Set <var data-name="mergedField">mergedField</var> to have arguments <span class="spec-call"><a href="#MergeArguments()" data-name="MergeArguments">MergeArguments</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span></li>
<li>return <var data-name="mergedField">mergedField</var></li>
</ol>
</div>
<p><em>Merging Output Fields:</em></p>
<pre id="example-ca2bf" class="spec-example" data-language="graphql"><a href="#example-ca2bf">Example № 85</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg3</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">OutputTypeA</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeArguments" secid="2.3.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeArguments">2.3.8</a></span>MergeArguments</h3>
<p>This algorithm merges the arguments of two fields from the same type of different subgraphs into a combined list of arguments. The algorithm expects that both fields have the same schema coordinate.</p>
<p>The arguments are merged by name, and the merged argument is the result of calling <span class="spec-call"><a href="#MergeArgument()" data-name="MergeArgument">MergeArgument</a>(<var data-name="argumentA">argumentA</var>, <var data-name="argumentB">argumentB</var>)</span>.</p>
<p>Only arguments that are defined on both fields are merged. If an argument is only defined on one field, it is not included in the merged list to ensure that the merged field is compatible with both subgraphs.</p>
<div class="spec-algo" id="MergeArguments()">
<span class="spec-call"><a href="#MergeArguments()" data-name="MergeArguments">MergeArguments</a>(<var data-name="fieldA">fieldA</var>, <var data-name="fieldB">fieldB</var>)</span><ol>
<li>Let <var data-name="mergedArguments">mergedArguments</var> be an empty list of ArgumentDefinitions</li>
<li>Let <var data-name="arguments">arguments</var> be the intersection of the set of argument names that are defined on <var data-name="fieldA">fieldA</var> and <var data-name="fieldB">fieldB</var> </li>
<li>For each <var data-name="argumentName">argumentName</var> in <var data-name="arguments">arguments</var>:<ol>
<li>Let <var data-name="argumentA">argumentA</var> be the argument with the same name on <var data-name="fieldA">fieldA</var></li>
<li>Let <var data-name="argumentB">argumentB</var> be the argument with the same name on <var data-name="fieldB">fieldB</var></li>
<li>If <var data-name="argumentA">argumentA</var> or <var data-name="argumentB">argumentB</var> are <code>@internal</code><ol>
<li>continue</li>
</ol>
</li>
<li>Let <var data-name="mergedArgument">mergedArgument</var> be the result of calling <span class="spec-call"><a href="#MergeArgument()" data-name="MergeArgument">MergeArgument</a>(<var data-name="argumentA">argumentA</var>, <var data-name="argumentB">argumentB</var>)</span></li>
<li>Append <var data-name="mergedArgument">mergedArgument</var> to <var data-name="mergedArguments">mergedArguments</var></li>
</ol>
</li>
<li>return <var data-name="mergedArguments">mergedArguments</var></li>
</ol>
</div>
<p><em>Merging Arguments:</em></p>
<pre id="example-b5a53" class="spec-example" data-language="graphql"><a href="#example-b5a53">Example № 86</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg3</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The following counter-example shows an invalid composition. The <code>field1</code> can be queried on the gateway with the argument <code>arg2</code>, which would lead to an execution error on subgraph B:</p>
<pre id="example-2ee18" class="spec-counter-example" data-language="graphql"><a href="#example-2ee18">Counter Example № 87</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">,</span> <span class="token attr-name">arg2</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeArgument" secid="2.3.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeArgument">2.3.9</a></span>MergeArgument</h3>
<p>This algorithm merges two arguments from the same field of different subgraphs into one. The algorithm expects that both arguments have the same schema coordinate.</p>
<p>The type of the argument is the result of calling <span class="spec-call"><a href="#MergeInputFieldType()" data-name="MergeInputFieldType">MergeInputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span>.</p>
<div class="spec-algo" id="MergeArgument()">
<span class="spec-call"><a href="#MergeArgument()" data-name="MergeArgument">MergeArgument</a>(<var data-name="argumentA">argumentA</var>, <var data-name="argumentB">argumentB</var>)</span><ol>
<li>Let <var data-name="mergedArgument">mergedArgument</var> be an empty ArgumentDefinition</li>
<li>Let <var data-name="typeA">typeA</var> be the type of argumentA</li>
<li>Let <var data-name="typeB">typeB</var> be the type of argumentB</li>
<li>Let <var data-name="mergedType">mergedType</var> be the result of calling <span class="spec-call"><a href="#MergeInputFieldType()" data-name="MergeInputFieldType">MergeInputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span></li>
<li>Set <var data-name="mergedArgument">mergedArgument</var> to have the same name as <var data-name="argumentA">argumentA</var></li>
<li>Set <var data-name="mergedArgument">mergedArgument</var> to have <var data-name="mergedType">mergedType</var> as its type</li>
<li>return <var data-name="mergedArgument">mergedArgument</var></li>
</ol>
</div>
<p><em>Merging Arguments:</em></p>
<pre id="example-998bc" class="spec-example" data-language="graphql"><a href="#example-998bc">Example № 88</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">(</span><span class="token attr-name">arg1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeInterfaceImplementation" secid="2.3.10">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeInterfaceImplementation">2.3.10</a></span>MergeInterfaceImplementation</h3>
<p>This algorithm merges the interfaces implemented by two types from different subgraphs into a combined list of interfaces. The algorithm ignores any interface that is marked as <code>@internal</code>, to avoid exposing a implementation that does not match a interface type.</p>
<div class="spec-algo" id="MergeInterfaceImplementation()">
<span class="spec-call"><a href="#MergeInterfaceImplementation()" data-name="MergeInterfaceImplementation">MergeInterfaceImplementation</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>Let <var data-name="interfaceNames">interfaceNames</var> be the set of interface names that are defined on either <var data-name="typeA">typeA</var> or <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="validInterfaceNames">validInterfaceNames</var> be the set of all interface in the composition that are not <code>@internal</code></li>
<li>Return the intersection of <var data-name="interfaceNames">interfaceNames</var> and <var data-name="validInterfaceNames">validInterfaceNames</var></li>
</ol>
</div>
<p><em>Merging Interface Implementations:</em></p>
<pre id="example-cc59b" class="spec-example" data-language="graphql"><a href="#example-cc59b">Example № 89</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging Interface Implementations with <code>@internal</code> Interfaces:</em></p>
<pre id="example-4ee4b" class="spec-example" data-language="graphql"><a href="#example-4ee4b">Example № 90</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The following counter-example shows an invalid composition. The <code>Type1</code> type implements the <code>Interface1</code> interface, but the <code>Interface1</code> interface is marked as <code>@internal</code> in subgraph A.</p>
<pre id="example-b5ac8" class="spec-counter-example" data-language="graphql"><a href="#example-b5ac8">Counter Example № 91</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token directive function">@internal</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeInputFieldType" secid="2.3.11">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeInputFieldType">2.3.11</a></span>MergeInputFieldType</h3>
<p>This algorithm merges two input types. The merge will result in the least permissive type, while still be compatible with both input types. </p>
<div class="spec-algo" id="MergeInputFieldType()">
<span class="spec-call"><a href="#MergeInputFieldType()" data-name="MergeInputFieldType">MergeInputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are the same<ol>
<li>return <var data-name="typeA">typeA</var></li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> is Non-Null and <var data-name="typeB">typeB</var> is Non-Null<ol>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the inner type of <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the inner type of <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="innerType">innerType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNonNullType()" data-name="EnsureNonNullType">EnsureNonNullType</a>(<var data-name="innerType">innerType</var>)</span></li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> is Non-Null and <var data-name="typeB">typeB</var> is nullable<ol>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the inner type of <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="mergedType">mergedType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="typeB">typeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNonNullType()" data-name="EnsureNonNullType">EnsureNonNullType</a>(<var data-name="mergedType">mergedType</var>)</span></li>
</ol>
</li>
<li>If <var data-name="typeB">typeB</var> is Non-Null and <var data-name="typeA">typeA</var> is nullable<ol>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the inner type of <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="mergedType">mergedType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNonNullType()" data-name="EnsureNonNullType">EnsureNonNullType</a>(<var data-name="mergedType">mergedType</var>)</span></li>
</ol>
</li>
<li>If both <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are List<ol>
<li>Let <var data-name="itemTypeA">itemTypeA</var> be the item type of <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="itemTypeB">itemTypeB</var> be the item type of <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="innerType">innerType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="itemTypeA">itemTypeA</var>, <var data-name="itemTypeB">itemTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#ToListType()" data-name="ToListType">ToListType</a>(<var data-name="innerType">innerType</var>)</span></li>
</ol>
</li>
<li>raise composition error</li>
</ol>
</div>
<p><em>Merging nullable and non-nullable types:</em></p>
<pre id="example-628d4" class="spec-example" data-language="graphql"><a href="#example-628d4">Example № 92</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">input</span> <span class="token object">Input1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging nullable and non-nullable list types:</em></p>
<pre id="example-548b8" class="spec-example" data-language="graphql"><a href="#example-548b8">Example № 93</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph C</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-MergeOutputFieldType" secid="2.3.12">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-MergeOutputFieldType">2.3.12</a></span>MergeOutputFieldType</h3>
<p>This algorithm merges two output types. The merge will result in the most permissive type, while still being compatible with both output types. This ensures that the data contract between the GraphQL Gateway and the API consumer can be fulfilled.</p>
<div class="spec-algo" id="MergeOutputFieldType()">
<span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="typeB">typeB</var>)</span><ol>
<li>If <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are the same<ol>
<li>return <var data-name="typeA">typeA</var></li>
</ol>
</li>
<li>If both <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are Non-Null<ol>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the inner type of <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the inner type of <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="innerType">innerType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNonNullType()" data-name="EnsureNonNullType">EnsureNonNullType</a>(<var data-name="innerType">innerType</var>)</span></li>
</ol>
</li>
<li>If <var data-name="typeA">typeA</var> is Non-Null and <var data-name="typeB">typeB</var> is nullable<ol>
<li>Let <var data-name="innerTypeA">innerTypeA</var> be the inner type of <var data-name="typeA">typeA</var></li>
<li>Let <var data-name="mergedType">mergedType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="innerTypeA">innerTypeA</var>, <var data-name="typeB">typeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNullableType()" data-name="EnsureNullableType">EnsureNullableType</a>(<var data-name="mergedType">mergedType</var>)</span></li>
</ol>
</li>
<li>If <var data-name="typeB">typeB</var> is Non-Null and <var data-name="typeA">typeA</var> is nullable<ol>
<li>Let <var data-name="innerTypeB">innerTypeB</var> be the inner type of <var data-name="typeB">typeB</var></li>
<li>Let <var data-name="mergedType">mergedType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="typeA">typeA</var>, <var data-name="innerTypeB">innerTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#EnsureNullableType()" data-name="EnsureNullableType">EnsureNullableType</a>(<var data-name="mergedType">mergedType</var>)</span></li>
</ol>
</li>
<li>If both <var data-name="typeA">typeA</var> and <var data-name="typeB">typeB</var> are Lists:<ol>
<li>Let <var data-name="itemTypeA">itemTypeA</var> be the item type of <var data-name="typeA">typeA</var>.</li>
<li>Let <var data-name="itemTypeB">itemTypeB</var> be the item type of <var data-name="typeB">typeB</var>.</li>
<li>Let <var data-name="innerType">innerType</var> be <span class="spec-call"><a href="#MergeOutputFieldType()" data-name="MergeOutputFieldType">MergeOutputFieldType</a>(<var data-name="itemTypeA">itemTypeA</var>, <var data-name="itemTypeB">itemTypeB</var>)</span></li>
<li>return <span class="spec-call"><a href="#ToListType()" data-name="ToListType">ToListType</a>(<var data-name="innerType">innerType</var>)</span></li>
</ol>
</li>
<li>raise composition error</li>
</ol>
</div>
<p><em>Merging nullable and non-nullable types:</em></p>
<pre id="example-60354" class="spec-example" data-language="graphql"><a href="#example-60354">Example № 94</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Merging nullable and non-nullable list types:</em></p>
<pre id="example-95f4f" class="spec-example" data-language="graphql"><a href="#example-95f4f">Example № 95</a><code><span class="token comment"># Subgraph A</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># Subgraph B</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token comment"># Result</span>
<span class="token keyword">type</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span>
  <span class="token attr-name">field1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-EnsureNonNullType" secid="2.3.13">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-EnsureNonNullType">2.3.13</a></span>EnsureNonNullType</h3>
<p>When merging types this helper ensures that the specified <var data-name="type">type</var> is a non-null type or it wraps the specified <var data-name="type">type</var> as a non-null type.</p>
<div class="spec-algo" id="EnsureNonNullType()">
<span class="spec-call"><a href="#EnsureNonNullType()" data-name="EnsureNonNullType">EnsureNonNullType</a>(<var data-name="type">type</var>)</span><ol>
<li>If <var data-name="type">type</var> is Non-Null<ol>
<li>return <var data-name="type">type</var></li>
</ol>
</li>
<li>Let <var data-name="nonNullType">nonNullType</var> be a new Non-Null type with <var data-name="type">type</var> as inner type</li>
<li>return <var data-name="nonNullType">nonNullType</var></li>
</ol>
</div>
<pre id="example-0e696" class="spec-example" data-language="graphql"><a href="#example-0e696">Example № 96</a><code><span class="token comment"># Before</span>
<span class="token scalar">String</span>

<span class="token comment"># After</span>
<span class="token scalar">String</span><span class="token operator">!</span>
</code></pre>
</section>
<section id="sec-EnsureNullableType" secid="2.3.14">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-EnsureNullableType">2.3.14</a></span>EnsureNullableType</h3>
<p>When merging types this helper ensures that the specified <var data-name="type">type</var> is a nullable type or it returns the inner type of the non-null type.</p>
<div class="spec-algo" id="EnsureNullableType()">
<span class="spec-call"><a href="#EnsureNullableType()" data-name="EnsureNullableType">EnsureNullableType</a>(<var data-name="type">type</var>)</span><ol>
<li>If <var data-name="type">type</var> is Non-Null<ol>
<li>Let <var data-name="innerType">innerType</var> be the inner type of <var data-name="type">type</var></li>
<li>return <var data-name="innerType">innerType</var></li>
</ol>
</li>
<li>return <var data-name="type">type</var></li>
</ol>
</div>
<pre id="example-06d4f" class="spec-example" data-language="graphql"><a href="#example-06d4f">Example № 97</a><code><span class="token comment"># Before</span>
<span class="token scalar">String</span><span class="token operator">!</span>

<span class="token comment"># After</span>
<span class="token scalar">String</span>
</code></pre>
</section>
<section id="sec-ToListType" secid="2.3.15">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-ToListType">2.3.15</a></span>ToListType</h3>
<p>This algorithm creates list type for the provided type.</p>
<div class="spec-algo" id="ToListType()">
<span class="spec-call"><a href="#ToListType()" data-name="ToListType">ToListType</a>(<var data-name="type">type</var>)</span><ol>
<li>Let <var data-name="listType">listType</var> be a new List type with <var data-name="type">type</var> as item type</li>
<li>return <var data-name="listType">listType</var></li>
</ol>
</div>
<pre id="example-94c4e" class="spec-example" data-language="graphql"><a href="#example-94c4e">Example № 98</a><code><span class="token comment"># Before</span>
<span class="token scalar">String</span>

<span class="token comment"># After</span>
<span class="token punctuation">[</span><span class="token scalar">String</span><span class="token punctuation">]</span>
</code></pre>
</section>
</section>
<section id="sec-Finalize" secid="2.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Finalize">2.4</a></span>Finalize</h2>
</section>
</section>
<section id="sec-Executor" secid="3">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Executor">3</a></span>Executor</h1>
<p>A distributed GraphQL executor acts as an orchestrator that uses schema metadata to rewrite a GraphQL request into a query plan. This plan resolves the required data from subgraphs and coerces this data into the result of the GraphQL request.</p>
<section id="sec-Configuration" secid="3.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Configuration">3.1</a></span>Configuration</h2>
<p>The supergraph is a GraphQL IDL document that contains metadata for the query planner that describes the relationship between type system members and the type system members on subgraphs.</p>
<section id="sec--variable" secid="3.1.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec--variable">3.1.1</a></span>@variable</h3>
<section id="sec--variable.TODO-We-might-need-the-type-stated-on-the-variable-as-we-might-want-to-change-resolvers-when-we-cannot-guarntee-data-in-some-cases" class="subsec">
<h6><a href="#sec--variable.TODO-We-might-need-the-type-stated-on-the-variable-as-we-might-want-to-change-resolvers-when-we-cannot-guarntee-data-in-some-cases" title="link to this subsection">TODO: We might need the type stated on the variable as we might want to change resolvers when we cannot guarntee data in some cases</a></h6>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@variable</span><span class="token punctuation">(</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token class-name">Name</span><span class="token operator">!</span>
  <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token class-name">FieldSelection</span>
  <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token class-name">Value</span>
  <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span><span class="token operator">!</span>
<span class="token punctuation">)</span> <span class="token keyword">repeatable</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>The <code>@variable</code> directive specifies how the value for a variable specified by a <code>@resolver</code> directive can be resolved from subgraphs.</p>
<p>A variable can be declared on object types to provide variable values for entity resolvers or on field resolvers.</p>
<pre id="example-f465d" class="spec-example" data-language="graphql"><a href="#example-f465d">Example № 99</a><code><span class="token keyword">type</span> <span class="token class-name">User</span>
  <span class="token directive function">@variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">User_id</span>"</span> <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">id</span>"</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>When declared on a field, variables represent conditional ways to resolve a value. Only if this field is included into a query, will this variable be available.</p>
<pre id="example-dd281" class="spec-example" data-language="graphql"><a href="#example-dd281">Example № 100</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">address</span><span class="token punctuation">:</span> <span class="token class-name">Address</span> <span class="token directive function">@variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"User_id"</span><span class="token punctuation">,</span> <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>@variable</code> directive specifies how data can be selected from a subgraph relative to the entity by specifying GraphQL field syntax in the <code>select</code> argument. The field syntax may refer to fields only available on a specific subgraph.</p>
<pre id="example-c4dae" class="spec-example" data-language="graphql"><a href="#example-c4dae">Example № 101</a><code><span class="token keyword">type</span> <span class="token class-name">Product</span>
  <span class="token directive function">@variable</span><span class="token punctuation">(</span>
    <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">Product_group_name</span>"</span>
    <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">group { name }</span>"</span>
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"ProductCatalog"</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token attr-name">dimension</span><span class="token punctuation">:</span> <span class="token class-name">ProductDimension</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-2a104" class="spec-example" data-language="graphql"><a href="#example-2a104">Example № 102</a><code><span class="token keyword">type</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
  <span class="token attr-name">dimension</span><span class="token punctuation">:</span> <span class="token class-name">ProductDimension</span>
  <span class="token attr-name">shippingEstimate</span><span class="token punctuation">(</span><span class="token attr-name">zip</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>
    <span class="token directive function">@variable</span><span class="token punctuation">(</span>
      <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">Product_dimension_weight</span>"</span>
      <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">dimension { weight }</span>"</span>
      <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"ProductCatalog"</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>To construct the complex variable values, the <code>@variable</code> directives allow using GraphQL value syntax from which it can refer to other variables.</p>
<pre id="example-32461" class="spec-example" data-language="graphql"><a href="#example-32461">Example № 103</a><code><span class="token keyword">type</span> <span class="token class-name">User</span>
  <span class="token directive function">@variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"User_id"</span><span class="token punctuation">,</span> <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"Account"</span><span class="token punctuation">)</span>
  <span class="token directive function">@variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"FilterObj"</span><span class="token punctuation">,</span> <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token string">"{ id: { eq: $User_id } }"</span><span class="token punctuation">,</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"Account"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>Field arguments are implicitly declared as variables and can be referenced within the GraphQL value syntax.</p>
<pre id="example-b60ad" class="spec-example" data-language="graphql"><a href="#example-b60ad">Example № 104</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">productById</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Product</span>
    <span class="token directive function">@variable</span><span class="token punctuation">(</span>
      <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">FilterObj</span>"</span>
      <span class="token attr-name">value</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">{ id: { eq: $id } }</span>"</span>
      <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"Account"</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec--variable.Arguments-" class="subsec">
<h6><a href="#sec--variable.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>name</code>: The name of the variable.</li>
<li><code>select</code>: Represents GraphQL field syntax and specifies the required data relative to an object type.</li>
<li><code>value</code>: Represents GraphQL value syntax and allows to construct a GraphQL value syntax by referencing variables.</li>
<li><code>subgraph</code>: The subgraph from which the variable value can be resolved.</li>
</ul>
</section>
<section id="sec--variable.Type-Validation-" class="subsec">
<h6><a href="#sec--variable.Type-Validation-" title="link to this subsection">Type Validation:</a></h6>
<p>Variables must be referenced by <code>@variable</code> or <code>@resolver</code> directives within the same type definition.</p>
<ol>
<li>Collect all names from <code>@variable</code> directives within the type definition in a set.</li>
<li>Collect all variable names from the operation syntax of the <code>@resolver</code> directives&rsquo; <code>operation</code> argument.</li>
<li>It must be ensured that both sets intersect for all elements.</li>
</ol>
</section>
</section>
<section id="sec--resolver" secid="3.1.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec--resolver">3.1.2</a></span>@resolver</h3>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
  <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token class-name">OperationDefinition</span><span class="token operator">!</span>
  <span class="token attr-name">kind</span><span class="token punctuation">:</span> <span class="token class-name">ResolverKind</span>
  <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span><span class="token operator">!</span>
<span class="token punctuation">)</span> <span class="token keyword">repeatable</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span>
</code></pre>
<p>The resolver directives specify an operation to fetch data from a subgraph. The <code>operation</code> argument specifies GraphQL operation syntax to define the operation.</p>
<pre id="example-699cd" class="spec-example" data-language="graphql"><a href="#example-699cd">Example № 105</a><code><span class="token keyword">type</span> <span class="token class-name">User</span>
  <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
    <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query($User_id: Int!) { userById(id: $User_id) { ... User } }</span>"</span>
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>The root selection set of an operation must only have a single root field which specifies how to fetch data for a field or type from a subgraph.</p>
<pre id="example-07ec6" class="spec-counter-example" data-language="graphql"><a href="#example-07ec6">Counter Example № 106</a><code><span class="token keyword">type</span> <span class="token class-name">User</span>
  <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
    <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query($User_id: Int!) { userById(id: $User_id) { ... User } someOtherData }</span>"</span> 
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>The fully qualified subgraph query is constructed in the query planning process by rewriting the fragment spread.</p>
<pre id="example-1a644" class="spec-example" data-language="graphql"><a href="#example-1a644">Example № 107</a><code><span class="token keyword">type</span> <span class="token class-name">User</span>
  <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
    <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query($User_id: ID!) { node(id: $User_id) { ... on Author { ... User } } }</span>"</span> 
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>The <code>kind</code> argument of the <code>@resolver</code> directive defines the type of the resolver.</p>
<p>By default a resolver represents a simple fetch from a subgraph.</p>
<pre id="example-ce6b1" class="spec-example" data-language="graphql"><a href="#example-ce6b1">Example № 108</a><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">root</span><span class="token punctuation">:</span> <span class="token class-name">Root</span>
    <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
      <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query { root { ... Root } }</span>"</span>
      <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<pre id="example-7a6a0" class="spec-example" data-language="graphql"><a href="#example-7a6a0">Example № 109</a><code><span class="token keyword">type</span> <span class="token class-name">Address</span>
  <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
    <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query($User_id: ID!) { node(id: $User_id) { ... on Author { ... User } } }</span>"</span>
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>The <code>BATCH</code> resolver is used to resolve entity data in a batch.</p>
<pre id="example-aedc1" class="spec-example" data-language="graphql"><a href="#example-aedc1">Example № 110</a><code><span class="token keyword">type</span> <span class="token class-name">Address</span>
  <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
    <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">query($User_id: [ID!]!) { nodes(ids: $User_id) { ... on User { ... User } } }</span>"</span> 
    <span class="token attr-name">kind</span><span class="token punctuation">:</span> <span class="token constant">BATCH</span> 
    <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>The <code>SUBSCRIBE</code> resolver may only be used in a subscription context to subscribe to a subgraph.</p>
<pre id="example-699b5" class="spec-example" data-language="graphql"><a href="#example-699b5">Example № 111</a><code><span class="token keyword">type</span> <span class="token class-name">Subscription</span> <span class="token punctuation">{</span>
  <span class="token attr-name">onEvent</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
    <span class="token directive function">@resolver</span><span class="token punctuation">(</span>
      <span class="token attr-name">operation</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">subscription { onEvent }</span>"</span>
      <span class="token attr-name">kind</span><span class="token punctuation">:</span> <span class="token constant">SUBSCRIBE</span>
      <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span>.<span class="token constant">ACCOUNT</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<section id="sec--resolver.Arguments-" class="subsec">
<h6><a href="#sec--resolver.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>operation</code>: Represents GraphQL operation definition syntax.</li>
<li><code>kind</code>: Specifies the operation kind.</li>
<li><code>subgraph</code>: The subgraph on which the resolver can be executed.</li>
</ul>
</section>
<section id="sec--resolver.Type-Validation-" class="subsec">
<h6><a href="#sec--resolver.Type-Validation-" title="link to this subsection">Type Validation:</a></h6>
<p>Variables declared by <code>@resolver</code> directives must be resolvable through <code>@variables</code> on the same type definition. The variable must be resolvable from a subgraph that is different than the one the <code>@resolver</code> directive declares.</p>
<ol>
<li>For each <var data-name="resolverDirective">resolverDirective</var> in <var data-name="typeDefinition">typeDefinition</var>:</li>
<li>For each <var data-name="variableDefinition">variableDefinition</var> in <var data-name="resolverDirective">resolverDirective</var>:</li>
<li>At least one <var data-name="variableDirective">variableDirective</var> can be found where <var data-name="variableDirective">variableDirective</var>.Name == <var data-name="resolverDirective">resolverDirective</var>.Name and <var data-name="variableDirective">variableDirective</var>.Subgraph != <var data-name="resolverDirective">resolverDirective</var>.Subgraph</li>
</ol>
</section>
</section>
<section id="sec--source" secid="3.1.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec--source">3.1.3</a></span>@source</h3>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@source</span><span class="token punctuation">(</span>
  <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Subgraphs</span><span class="token operator">!</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token class-name">Name</span>
<span class="token punctuation">)</span> <span class="token keyword">repeatable</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span> <span class="token operator">|</span> <span class="token constant">FIELD_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">ENUM</span> <span class="token operator">|</span> <span class="token constant">ENUM_VALUE</span> <span class="token operator">|</span> <span class="token constant">INPUT_OBJECT</span> <span class="token operator">|</span> <span class="token constant">INPUT_FIELD_DEFINITION</span> <span class="token operator">|</span> <span class="token constant">SCALAR</span>
</code></pre>
<p>The <code>@source</code> directive specifies on which subgraphs a type system member is available.</p>
<pre id="example-49577" class="spec-example" data-language="graphql"><a href="#example-49577">Example № 112</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token scalar">String</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token constant">B</span><span class="token punctuation">)</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token constant">A</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>If a type system name differs accross subgraphs, the <code>@source</code> directive may specify the name of the type system member at the subgraph.</p>
<pre id="example-4ca09" class="spec-example" data-language="graphql"><a href="#example-4ca09">Example № 113</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"DisplayName"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<section id="sec--source.Arguments-" class="subsec">
<h6><a href="#sec--source.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>subgraph</code>: The subgraph from which the type system member is resolvable.</li>
<li><code>name</code>: Specifies the name of a type system member on a subgraph.</li>
</ul>
</section>
</section>
<section id="sec--owner" secid="3.1.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec--owner">3.1.4</a></span>@owner</h3>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@owner</span><span class="token punctuation">(</span><span class="token attr-name">subgraphs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Name</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">OBJECT</span>
</code></pre>
<p>Subgraphs that own an entity can be used to resolve this entity and determine if an entity exists. Multiple subgraphs can own an entity. All other subgraphs are considered to only hold patch data.</p>
<pre id="example-242fd" class="spec-example" data-language="graphql"><a href="#example-242fd">Example № 114</a><code><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token directive function">@owner</span><span class="token punctuation">(</span><span class="token attr-name">subgraphs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span> <span class="token scalar">String</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"B"</span><span class="token punctuation">)</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@source</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"A"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<section id="sec--owner.Arguments-" class="subsec">
<h6><a href="#sec--owner.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>subgraphs</code>: The subgraphs from which an entity implementing the <code>Node</code> interface can be resolved from.</li>
</ul>
</section>
<section id="sec--owner.Type-Validation-" class="subsec">
<h6><a href="#sec--owner.Type-Validation-" title="link to this subsection">Type Validation:</a></h6>
<p>Object type definitions annotated with this directive must implement the <code>Node</code> interface.</p>
</section>
</section>
<section id="sec-Subgraphs" secid="3.1.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Subgraphs">3.1.5</a></span>Subgraphs</h3>
<pre data-language="graphql"><code><span class="token keyword">enum</span> <span class="token class-name">Subgraphs</span> <span class="token punctuation">{</span>
  <span class="token constant">NAME_OF_SUBGRAPH_1</span>
  <span class="token constant">NAME_OF_SUBGRAPH_2</span>
  <span class="token constant">NAME_OF_SUBGRAPH_3</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec--transport" secid="3.1.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec--transport">3.1.6</a></span>@transport</h3>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@transport</span><span class="token punctuation">(</span>
  <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token class-name">Name</span><span class="token operator">!</span>
  <span class="token attr-name">protocol</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>
  <span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token constant">URI</span><span class="token operator">!</span>
  <span class="token attr-name">group</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
<span class="token punctuation">)</span> <span class="token keyword">repeatable</span> <span class="token keyword">on</span> <span class="token constant">SCHEMA</span>
</code></pre>
<p>The <code>@transport</code> directive specifies the transport protocol to resolve data from a subgraph.</p>
<pre id="example-42a48" class="spec-example" data-language="graphql"><a href="#example-42a48">Example № 115</a><code><span class="token keyword">schema</span>
  <span class="token directive function">@transport</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">A</span>"</span> <span class="token attr-name">protocol</span><span class="token punctuation">:</span> <span class="token string">"GRAPHQL-HTTP"</span><span class="token punctuation">,</span> <span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token string">"http://localhost:1234/graphql"</span><span class="token punctuation">)</span>
  <span class="token directive function">@transport</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">A</span>"</span> <span class="token attr-name">protocol</span><span class="token punctuation">:</span> <span class="token string">"GRAPHQL-SSE"</span><span class="token punctuation">,</span> <span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token string">"http://localhost:1234/graphql"</span><span class="token punctuation">)</span>
  <span class="token directive function">@transport</span><span class="token punctuation">(</span><span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">A</span>"</span> <span class="token attr-name">protocol</span><span class="token punctuation">:</span> <span class="token string">"GRAPHQL-WS"</span><span class="token punctuation">,</span> <span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token string">"ws://localhost:1234/graphql"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<section id="sec--transport.Arguments-" class="subsec">
<h6><a href="#sec--transport.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>subgraph</code>: The subgraph for which a protocol was defined.</li>
<li><code>protocol</code>: A string representing the transport protocol.</li>
<li><code>location</code>: A URI representing the transport resource.</li>
<li><code>group</code>: An option string allowing to express configuration grouping.</li>
</ul>
</section>
</section>
<section id="sec-ResolverKind" secid="3.1.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-ResolverKind">3.1.7</a></span>ResolverKind</h3>
<pre data-language="graphql"><code><span class="token keyword">enum</span> <span class="token class-name">ResolverKind</span> <span class="token punctuation">{</span>
  <span class="token constant">FETCH</span>
  <span class="token constant">BATCH</span>
  <span class="token constant">SUBSCRIBE</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>ResolverKind</code> enum defines the resolver types.</p>
</section>
<section id="sec-Value" secid="3.1.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Value">3.1.8</a></span>Value</h3>
<pre data-language="graphql"><code><span class="token keyword">scalar</span> <span class="token class-name">Value</span>
</code></pre>
<p>The <code>Value</code> scalar represents GraphQL value syntax.</p>
</section>
</section>
</section>
<section id="sec-Shared-Types" secid="4">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Shared-Types">4</a></span>Shared Types</h1>
<p>In this section we outline directives and types that are shared between the subgraph configuration and the gateway configuration document.</p>
<section id="sec--fusion" secid="4.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec--fusion">4.1</a></span>@fusion</h2>
<pre data-language="graphql"><code><span class="token keyword">directive</span> <span class="token directive function">@fusion</span><span class="token punctuation">(</span>
  <span class="token attr-name">prefix</span><span class="token punctuation">:</span> <span class="token scalar">String</span>
  <span class="token attr-name">prefixSelf</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span><span class="token operator">!</span> <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token class-name">Version</span><span class="token operator">!</span>
<span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token constant">SCHEMA</span>
</code></pre>
<p>The <code>@fusion</code> directive is applied to a schema definition node or a schema extension node in a GraphQL schema document and defines the Fusion specification version that the configuration document follows. If the version is not explicitly stated, Fusion tooling is expected to select the newest specification version the tooling follows.</p>
<pre id="example-cbc30" class="spec-example" data-language="graphql"><a href="#example-cbc30">Example № 116</a><code><span class="token keyword">schema</span> <span class="token directive function">@fusion</span><span class="token punctuation">(</span><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token string">"2023-12.rfc-1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token attr-name">query</span><span class="token punctuation">:</span> <span class="token class-name">Query</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In addition, it specifies a prefix for Fusion-specific types and directives to prevent naming collisions with user-defined schema types or directives.</p>
<pre id="example-4b364" class="spec-example" data-language="graphql"><a href="#example-4b364">Example № 117</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Bar</span>
  <span class="token directive function">@fusion__variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">field</span>"</span> <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">field</span>"</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"subgraphName"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">schema</span>
  <span class="token directive function">@fusion</span><span class="token punctuation">(</span><span class="token attr-name">prefix</span><span class="token punctuation">:</span> <span class="token string">"fusion"</span><span class="token punctuation">,</span> <span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token string">"2023-12.rfc-1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>If the <code>prefixSelf</code> argument is set to <code>true</code>, the prefix will also be applied to the <code>@fusion</code> directive itself.</p>
<pre id="example-53043" class="spec-example" data-language="graphql"><a href="#example-53043">Example № 118</a><code><span class="token keyword">extend</span> <span class="token keyword">type</span> <span class="token class-name">Bar</span>
  <span class="token directive function">@fusion__variable</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">field</span>"</span> <span class="token attr-name">select</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">field</span>"</span> <span class="token attr-name">subgraph</span><span class="token punctuation">:</span> <span class="token string">"subgraphName"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">schema</span> <span class="token directive function">@fusion__fusion</span><span class="token punctuation">(</span><span class="token attr-name">prefix</span><span class="token punctuation">:</span> <span class="token description string">"<span class="token language-markdown">fusion</span>"</span> <span class="token attr-name">prefixSelf</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token string">"2023-12.rfc-1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<section id="sec--fusion.Arguments-" class="subsec">
<h6><a href="#sec--fusion.Arguments-" title="link to this subsection">Arguments:</a></h6>
<ul>
<li><code>version</code>: Specifies the version of the Fusion specification the document aligns with. The version string consists of the year and month the spec was released, e.g., <code>2023-12</code>.</li>
<li><code>prefix</code>: This string defines the prefix for Fusion-specific types and directives.</li>
<li><code>prefixSelf</code>: A boolean that, when set to <code>true</code>, applies the specified prefix to the <code>@fusion</code> directive itself.</li>
</ul>
</section>
</section>
<section id="sec-Name" secid="4.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Name">4.2</a></span>Name</h2>
<pre data-language="graphql"><code><span class="token keyword">scalar</span> <span class="token class-name">Name</span>
</code></pre>
<p>The scalar <code>Name</code> represents a valid GraphQL type name.</p>
</section>
<section id="sec-FieldSelection" secid="4.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-FieldSelection">4.3</a></span>FieldSelection</h2>
<pre data-language="graphql"><code><span class="token keyword">scalar</span> <span class="token class-name">FieldSelection</span>
</code></pre>
<p>The scalar <code>FieldSelection</code> represents a GraphQL field selection syntax.</p>
<pre id="example-fa3a8" class="spec-example" data-language="graphql"><a href="#example-fa3a8">Example № 119</a><code><span class="token property-query">abc</span><span class="token punctuation">(</span><span class="token attr-name">def</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token property">ghi</span> <span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-Version" secid="4.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Version">4.4</a></span>Version</h2>
<pre data-language="graphql"><code><span class="token keyword">scalar</span> <span class="token class-name">Version</span>
</code></pre>
</section>
</section>
<section id="sec-Appendix-Definitions" secid="A">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Definitions">A</a></span>Appendix: Definitions</h1>
<p>This specification document outlines definitions used in the GraphQL Composite Schemas spec to avoid ambiguity.</p>
<section id="sec-Appendix-Definitions.Composite-Types" secid="A.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Definitions.Composite-Types">A.1</a></span>Composite Types</h2>
<p>Composite Type in the GraphQL Composite Schemas spec is defined as a Union-, Interface- or Object-Type. </p>
</section>
</section>
<section id="index" secid="index" class="spec-index">
<h1>
<span class="spec-secid" title="link to the index"><a href="#index">§</a></span>Index</h1>
<ol>
<li><a href="#ArgumentsAreMergable()">ArgumentsAreMergable</a></li>
<li><a href="#BuildSubgraphSchema()">BuildSubgraphSchema</a></li>
<li><a href="#CommonArguments()">CommonArguments</a></li>
<li><a href="#CommonFields()">CommonFields</a></li>
<li><a href="#ComposeConfiguration()">ComposeConfiguration</a></li>
<li><a href="#EnsureNonNullType()">EnsureNonNullType</a></li>
<li><a href="#EnsureNullableType()">EnsureNullableType</a></li>
<li><a href="#EnumAreMergable()">EnumAreMergable</a></li>
<li><a href="#FieldsAreMergable()">FieldsAreMergable</a></li>
<li><a href="#HasQueryRootType()">HasQueryRootType</a></li>
<li><a href="#InputFieldsAreMergable()">InputFieldsAreMergable</a></li>
<li><a href="#InputFieldsHaveConsistentDefaults()">InputFieldsHaveConsistentDefaults</a></li>
<li><a href="#IsEnumEmpty()">IsEnumEmpty</a></li>
<li><a href="#IsExposed()">IsExposed</a></li>
<li><a href="#IsInputObjectTypeEmpty()">IsInputObjectTypeEmpty</a></li>
<li><a href="#IsInterfaceTypeEmpty()">IsInterfaceTypeEmpty</a></li>
<li><a href="#IsObjectTypeEmpty()">IsObjectTypeEmpty</a></li>
<li><a href="#MergeArgument()">MergeArgument</a></li>
<li><a href="#MergeArguments()">MergeArguments</a></li>
<li><a href="#MergeEnumType()">MergeEnumType</a></li>
<li><a href="#MergeInputField()">MergeInputField</a></li>
<li><a href="#MergeInputFieldType()">MergeInputFieldType</a></li>
<li><a href="#MergeInputType()">MergeInputType</a></li>
<li><a href="#MergeInterfaceImplementation()">MergeInterfaceImplementation</a></li>
<li><a href="#MergeInterfaceType()">MergeInterfaceType</a></li>
<li><a href="#MergeOutputField()">MergeOutputField</a></li>
<li><a href="#MergeOutputFieldType()">MergeOutputFieldType</a></li>
<li><a href="#MergeOutputType()">MergeOutputType</a></li>
<li><a href="#MergeSchema()">MergeSchema</a></li>
<li><a href="#MergeType()">MergeType</a></li>
<li><a href="#MergeUnionType()">MergeUnionType</a></li>
<li><a href="#SameTypeShape()">SameTypeShape</a></li>
<li><a href="#ToListType()">ToListType</a></li>
<li><a href="#ValidateArgumentDefaultValues()">ValidateArgumentDefaultValues</a></li>
<li><a href="#ValidateDefaultValue()">ValidateDefaultValue</a></li>
<li><a href="#ValidateInputFieldDefaultValues()">ValidateInputFieldDefaultValues</a></li>
</ol>
</section>
</article>
<footer>
Written in <a href="https://spec-md.com" target="_blank">Spec Markdown</a>.</footer>
<input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden><div class="spec-sidebar-button">&#x2630;</div></label>
<div class="spec-sidebar" aria-hidden>
<div class="spec-toc">
<div class="title"><a href="#">GraphQL Composite Schemas Spec</a></div>
<ol><li id="_sidebar_1"><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a>
<input hidden class="toggle" type="checkbox" id="_toggle_1" /><label for="_toggle_1"></label>
<ol>
<li id="_sidebar_1.1"><a href="#sec-Overview.Entities"><span class="spec-secid">1.1</span>Entities</a></li>
<li id="_sidebar_1.2"><a href="#sec-Keys"><span class="spec-secid">1.2</span>Keys</a></li>
</ol>
</li>
<li id="_sidebar_2"><a href="#sec-Composition"><span class="spec-secid">2</span>Composition</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2" /><label for="_toggle_2"></label>
<ol>
<li id="_sidebar_2.1"><a href="#sec-Directives"><span class="spec-secid">2.1</span>Directives</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.1" /><label for="_toggle_2.1"></label>
<ol>
<li id="_sidebar_2.1.1"><a href="#sec-Directives.Entities"><span class="spec-secid">2.1.1</span>Entities</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.1.1" /><label for="_toggle_2.1.1"></label>
<ol>
<li id="_sidebar_2.1.1.1"><a href="#sec--entityResolver"><span class="spec-secid">2.1.1.1</span>@entityResolver</a></li>
<li id="_sidebar_2.1.1.2"><a href="#sec--is"><span class="spec-secid">2.1.1.2</span>@is</a></li>
</ol>
</li>
<li id="_sidebar_2.1.2"><a href="#sec-Shared-Data"><span class="spec-secid">2.1.2</span>Shared Data</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.1.2" /><label for="_toggle_2.1.2"></label>
<ol>
<li id="_sidebar_2.1.2.1"><a href="#sec--shareable"><span class="spec-secid">2.1.2.1</span>@shareable</a></li>
<li id="_sidebar_2.1.2.2"><a href="#sec--require"><span class="spec-secid">2.1.2.2</span>@require</a></li>
<li id="_sidebar_2.1.2.3"><a href="#sec--provides"><span class="spec-secid">2.1.2.3</span>@provides</a></li>
<li id="_sidebar_2.1.2.4"><a href="#sec--external"><span class="spec-secid">2.1.2.4</span>@external</a></li>
<li id="_sidebar_2.1.2.5"><a href="#sec--override"><span class="spec-secid">2.1.2.5</span>@override</a></li>
</ol>
</li>
<li id="_sidebar_2.1.3"><a href="#sec-Reshaping"><span class="spec-secid">2.1.3</span>Reshaping</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.1.3" /><label for="_toggle_2.1.3"></label>
<ol>
<li id="_sidebar_2.1.3.1"><a href="#sec--internal"><span class="spec-secid">2.1.3.1</span>@internal</a></li>
</ol>
</li>
<li id="_sidebar_2.1.4"><a href="#sec-SchemaCoordinate"><span class="spec-secid">2.1.4</span>SchemaCoordinate</a></li>
</ol>
</li>
<li id="_sidebar_2.2"><a href="#sec-Validate"><span class="spec-secid">2.2</span>Validate</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2" /><label for="_toggle_2.2"></label>
<ol>
<li id="_sidebar_2.2.1"><a href="#sec-Types"><span class="spec-secid">2.2.1</span>Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.1" /><label for="_toggle_2.2.1"></label>
<ol>
<li id="_sidebar_2.2.1.1"><a href="#sec-Semantical-Equvalence"><span class="spec-secid">2.2.1.1</span>Semantical Equvalence</a></li>
</ol>
</li>
<li id="_sidebar_2.2.2"><a href="#sec-Validate.Composite-Types"><span class="spec-secid">2.2.2</span>Composite Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.2" /><label for="_toggle_2.2.2"></label>
<ol>
<li id="_sidebar_2.2.2.1"><a href="#sec-Field-Types-Mergable"><span class="spec-secid">2.2.2.1</span>Field Types Mergable</a></li>
<li id="_sidebar_2.2.2.2"><a href="#sec-Argument-Types-Mergable"><span class="spec-secid">2.2.2.2</span>Argument Types Mergable</a></li>
<li id="_sidebar_2.2.2.3"><a href="#sec-Arguments-Mergable"><span class="spec-secid">2.2.2.3</span>Arguments Mergable</a></li>
<li id="_sidebar_2.2.2.4"><a href="#sec-Required-Arguments-Cannot-Be-Internal"><span class="spec-secid">2.2.2.4</span>Required Arguments Cannot Be Internal</a></li>
<li id="_sidebar_2.2.2.5"><a href="#sec-Public-Fields-Cannot-Reference-Internals"><span class="spec-secid">2.2.2.5</span>Public Fields Cannot Reference Internals</a></li>
</ol>
</li>
<li id="_sidebar_2.2.3"><a href="#sec-Object-Types"><span class="spec-secid">2.2.3</span>Object Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.3" /><label for="_toggle_2.2.3"></label>
<ol>
<li id="_sidebar_2.2.3.1"><a href="#sec-Empty-Merged-Object-Type"><span class="spec-secid">2.2.3.1</span>Empty Merged Object Type</a></li>
</ol>
</li>
<li id="_sidebar_2.2.4"><a href="#sec-Input-Object-Types"><span class="spec-secid">2.2.4</span>Input Object Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.4" /><label for="_toggle_2.2.4"></label>
<ol>
<li id="_sidebar_2.2.4.1"><a href="#sec-Input-Field-Types-Mergable"><span class="spec-secid">2.2.4.1</span>Input Field Types Mergable</a></li>
<li id="_sidebar_2.2.4.2"><a href="#sec-Input-With-Different-Fields"><span class="spec-secid">2.2.4.2</span>Input With Different Fields</a></li>
<li id="_sidebar_2.2.4.3"><a href="#sec-Empty-Merged-Input-Object-Type"><span class="spec-secid">2.2.4.3</span>Empty Merged Input Object Type</a></li>
<li id="_sidebar_2.2.4.4"><a href="#sec-Input-Field-Default-Mismatch"><span class="spec-secid">2.2.4.4</span>Input Field Default Mismatch</a></li>
<li id="_sidebar_2.2.4.5"><a href="#sec-Public-Input-Fields-Cannot-Reference-Internals"><span class="spec-secid">2.2.4.5</span>Public Input Fields Cannot Reference Internals</a></li>
<li id="_sidebar_2.2.4.6"><a href="#sec-Required-Input-Fields-cannot-be-internal"><span class="spec-secid">2.2.4.6</span>Required Input Fields cannot be internal</a></li>
</ol>
</li>
<li id="_sidebar_2.2.5"><a href="#sec-Enum-Types"><span class="spec-secid">2.2.5</span>Enum Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.5" /><label for="_toggle_2.2.5"></label>
<ol>
<li id="_sidebar_2.2.5.1"><a href="#sec-Values-Must-Be-The-Same-Across-Subgraphs"><span class="spec-secid">2.2.5.1</span>Values Must Be The Same Across Subgraphs</a></li>
<li id="_sidebar_2.2.5.2"><a href="#sec-Default-Value-Uses-Internals"><span class="spec-secid">2.2.5.2</span>Default Value Uses Internals</a></li>
<li id="_sidebar_2.2.5.3"><a href="#sec-Empty-Merged-Enum-Type"><span class="spec-secid">2.2.5.3</span>Empty Merged Enum Type</a></li>
</ol>
</li>
<li id="_sidebar_2.2.6"><a href="#sec-Interface"><span class="spec-secid">2.2.6</span>Interface</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.6" /><label for="_toggle_2.2.6"></label>
<ol>
<li id="_sidebar_2.2.6.1"><a href="#sec-Empty-Merged-Interface-Type"><span class="spec-secid">2.2.6.1</span>Empty Merged Interface Type</a></li>
</ol>
</li>
<li id="_sidebar_2.2.7"><a href="#sec-Union"><span class="spec-secid">2.2.7</span>Union</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.7" /><label for="_toggle_2.2.7"></label>
<ol>
<li id="_sidebar_2.2.7.1"><a href="#sec-Union-Type-Members-Cannot-Reference-Internals"><span class="spec-secid">2.2.7.1</span>Union Type Members Cannot Reference Internals</a></li>
</ol>
</li>
<li id="_sidebar_2.2.8"><a href="#sec-Schema"><span class="spec-secid">2.2.8</span>Schema</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.8" /><label for="_toggle_2.2.8"></label>
<ol>
<li id="_sidebar_2.2.8.1"><a href="#sec-No-Queries"><span class="spec-secid">2.2.8.1</span>No Queries</a></li>
</ol>
</li>
<li id="_sidebar_2.2.9"><a href="#sec-Shared-Functions"><span class="spec-secid">2.2.9</span>Shared Functions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.2.9" /><label for="_toggle_2.2.9"></label>
<ol>
<li id="_sidebar_2.2.9.1"><a href="#sec-Same-Type-Shape"><span class="spec-secid">2.2.9.1</span>Same Type Shape</a></li>
<li id="_sidebar_2.2.9.2"><a href="#sec-Is-Exposed"><span class="spec-secid">2.2.9.2</span>Is Exposed</a></li>
</ol>
</li>
</ol>
</li>
<li id="_sidebar_2.3"><a href="#sec-Compose"><span class="spec-secid">2.3</span>Compose</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2.3" /><label for="_toggle_2.3"></label>
<ol>
<li id="_sidebar_2.3.1"><a href="#sec-MergeObjectType"><span class="spec-secid">2.3.1</span>MergeObjectType</a></li>
<li id="_sidebar_2.3.2"><a href="#sec-MergeInputType"><span class="spec-secid">2.3.2</span>MergeInputType</a></li>
<li id="_sidebar_2.3.3"><a href="#sec-MergeInterfaceType"><span class="spec-secid">2.3.3</span>MergeInterfaceType</a></li>
<li id="_sidebar_2.3.4"><a href="#sec-MergeUnionType"><span class="spec-secid">2.3.4</span>MergeUnionType</a></li>
<li id="_sidebar_2.3.5"><a href="#sec-MergeEnumType"><span class="spec-secid">2.3.5</span>MergeEnumType</a></li>
<li id="_sidebar_2.3.6"><a href="#sec-MergeInputField"><span class="spec-secid">2.3.6</span>MergeInputField</a></li>
<li id="_sidebar_2.3.7"><a href="#sec-MergeOutputField"><span class="spec-secid">2.3.7</span>MergeOutputField</a></li>
<li id="_sidebar_2.3.8"><a href="#sec-MergeArguments"><span class="spec-secid">2.3.8</span>MergeArguments</a></li>
<li id="_sidebar_2.3.9"><a href="#sec-MergeArgument"><span class="spec-secid">2.3.9</span>MergeArgument</a></li>
<li id="_sidebar_2.3.10"><a href="#sec-MergeInterfaceImplementation"><span class="spec-secid">2.3.10</span>MergeInterfaceImplementation</a></li>
<li id="_sidebar_2.3.11"><a href="#sec-MergeInputFieldType"><span class="spec-secid">2.3.11</span>MergeInputFieldType</a></li>
<li id="_sidebar_2.3.12"><a href="#sec-MergeOutputFieldType"><span class="spec-secid">2.3.12</span>MergeOutputFieldType</a></li>
<li id="_sidebar_2.3.13"><a href="#sec-EnsureNonNullType"><span class="spec-secid">2.3.13</span>EnsureNonNullType</a></li>
<li id="_sidebar_2.3.14"><a href="#sec-EnsureNullableType"><span class="spec-secid">2.3.14</span>EnsureNullableType</a></li>
<li id="_sidebar_2.3.15"><a href="#sec-ToListType"><span class="spec-secid">2.3.15</span>ToListType</a></li>
</ol>
</li>
<li id="_sidebar_2.4"><a href="#sec-Finalize"><span class="spec-secid">2.4</span>Finalize</a></li>
</ol>
</li>
<li id="_sidebar_3"><a href="#sec-Executor"><span class="spec-secid">3</span>Executor</a>
<input hidden class="toggle" type="checkbox" id="_toggle_3" /><label for="_toggle_3"></label>
<ol>
<li id="_sidebar_3.1"><a href="#sec-Configuration"><span class="spec-secid">3.1</span>Configuration</a>
<input hidden class="toggle" type="checkbox" id="_toggle_3.1" /><label for="_toggle_3.1"></label>
<ol>
<li id="_sidebar_3.1.1"><a href="#sec--variable"><span class="spec-secid">3.1.1</span>@variable</a></li>
<li id="_sidebar_3.1.2"><a href="#sec--resolver"><span class="spec-secid">3.1.2</span>@resolver</a></li>
<li id="_sidebar_3.1.3"><a href="#sec--source"><span class="spec-secid">3.1.3</span>@source</a></li>
<li id="_sidebar_3.1.4"><a href="#sec--owner"><span class="spec-secid">3.1.4</span>@owner</a></li>
<li id="_sidebar_3.1.5"><a href="#sec-Subgraphs"><span class="spec-secid">3.1.5</span>Subgraphs</a></li>
<li id="_sidebar_3.1.6"><a href="#sec--transport"><span class="spec-secid">3.1.6</span>@transport</a></li>
<li id="_sidebar_3.1.7"><a href="#sec-ResolverKind"><span class="spec-secid">3.1.7</span>ResolverKind</a></li>
<li id="_sidebar_3.1.8"><a href="#sec-Value"><span class="spec-secid">3.1.8</span>Value</a></li>
</ol>
</li>
</ol>
</li>
<li id="_sidebar_4"><a href="#sec-Shared-Types"><span class="spec-secid">4</span>Shared Types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_4" /><label for="_toggle_4"></label>
<ol>
<li id="_sidebar_4.1"><a href="#sec--fusion"><span class="spec-secid">4.1</span>@fusion</a></li>
<li id="_sidebar_4.2"><a href="#sec-Name"><span class="spec-secid">4.2</span>Name</a></li>
<li id="_sidebar_4.3"><a href="#sec-FieldSelection"><span class="spec-secid">4.3</span>FieldSelection</a></li>
<li id="_sidebar_4.4"><a href="#sec-Version"><span class="spec-secid">4.4</span>Version</a></li>
</ol>
</li>
<li id="_sidebar_A"><a href="#sec-Appendix-Definitions"><span class="spec-secid">A</span>Appendix: Definitions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_A" /><label for="_toggle_A"></label>
<ol>
<li id="_sidebar_A.1"><a href="#sec-Appendix-Definitions.Composite-Types"><span class="spec-secid">A.1</span>Composite Types</a></li>
</ol>
</li>
<li id="_sidebar_index"><a href="#index"><span class="spec-secid">§</span>Index</a></li>
</ol>
</div>
</div>
</body>
</html>
